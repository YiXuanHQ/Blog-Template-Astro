---
title: å…³ç³»å‹æ•°æ®åº“
date: 2025-01-22
prevChapter: "harmonyos-dev/07-data-management/01-Preferencesè½»é‡çº§å­˜å‚¨"
nextChapter: "harmonyos-dev/07-data-management/03-åˆ†å¸ƒå¼æ•°æ®æœåŠ¡"
parentChapter: "harmonyos-dev/07-data-management/README"
---
# å…³ç³»å‹æ•°æ®åº“

> ä½¿ç”¨ RDB ç®¡ç†ç»“æ„åŒ–æ•°æ®

## ğŸ“š RDB æ¦‚è¿°

å…³ç³»å‹æ•°æ®åº“ï¼ˆRDBï¼‰é€‚ç”¨äºå­˜å‚¨å¤§é‡ç»“æ„åŒ–æ•°æ®ã€‚

### é€‚ç”¨åœºæ™¯

```
âœ… é€‚åˆ
â”œâ”€ å¤§é‡æ•°æ®å­˜å‚¨
â”œâ”€ å¤æ‚æŸ¥è¯¢
â”œâ”€ æ•°æ®å…³è”
â””â”€ äº‹åŠ¡å¤„ç†

âŒ ä¸é€‚åˆ
â””â”€ ç®€å•é”®å€¼å¯¹ï¼ˆç”¨ Preferencesï¼‰
```

## ğŸ”§ åŸºæœ¬æ“ä½œ

### åˆ›å»ºæ•°æ®åº“

```typescript
import relationalStore from '@ohos.data.relationalStore'

// æ•°æ®åº“é…ç½®
const STORE_CONFIG = {
  name: 'MyDatabase.db',
  securityLevel: relationalStore.SecurityLevel.S1
}

// åˆ›å»ºè¡¨çš„ SQL
const SQL_CREATE_TABLE = `
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INTEGER,
    email TEXT UNIQUE,
    created_at INTEGER
  )
`

// è·å–æ•°æ®åº“å®ä¾‹
const store = await relationalStore.getRdbStore(context, STORE_CONFIG)

// åˆ›å»ºè¡¨
await store.executeSql(SQL_CREATE_TABLE)
```

### æ’å…¥æ•°æ®

```typescript
// æ’å…¥å•æ¡
const valueBucket = {
  name: 'Alice',
  age: 25,
  email: 'alice@example.com',
  created_at: Date.now()
}

const rowId = await store.insert('users', valueBucket)
console.log('æ’å…¥æˆåŠŸï¼ŒID:', rowId)

// æ‰¹é‡æ’å…¥
const users = [
  { name: 'Bob', age: 30, email: 'bob@example.com', created_at: Date.now() },
  { name: 'Charlie', age: 28, email: 'charlie@example.com', created_at: Date.now() }
]

for (const user of users) {
  await store.insert('users', user)
}
```

### æŸ¥è¯¢æ•°æ®

```typescript
// æŸ¥è¯¢æ‰€æœ‰
const predicates = new relationalStore.RdbPredicates('users')
const resultSet = await store.query(predicates)

const users = []
while (resultSet.goToNextRow()) {
  users.push({
    id: resultSet.getLong(resultSet.getColumnIndex('id')),
    name: resultSet.getString(resultSet.getColumnIndex('name')),
    age: resultSet.getLong(resultSet.getColumnIndex('age')),
    email: resultSet.getString(resultSet.getColumnIndex('email'))
  })
}
resultSet.close()

console.log('æŸ¥è¯¢ç»“æœ:', users)

// æ¡ä»¶æŸ¥è¯¢
const predicates2 = new relationalStore.RdbPredicates('users')
predicates2.equalTo('name', 'Alice')
const resultSet2 = await store.query(predicates2)
```

### æ›´æ–°æ•°æ®

```typescript
const valueBucket = {
  age: 26
}

const predicates = new relationalStore.RdbPredicates('users')
predicates.equalTo('name', 'Alice')

const rows = await store.update(valueBucket, predicates)
console.log('æ›´æ–°è¡Œæ•°:', rows)
```

### åˆ é™¤æ•°æ®

```typescript
const predicates = new relationalStore.RdbPredicates('users')
predicates.equalTo('name', 'Bob')

const rows = await store.delete(predicates)
console.log('åˆ é™¤è¡Œæ•°:', rows)
```

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹

### ç¬”è®°åº”ç”¨æ•°æ®åº“

```typescript
import relationalStore from '@ohos.data.relationalStore'

class NotesDatabase {
  private store: relationalStore.RdbStore
  
  async init(context) {
    const config = {
      name: 'notes.db',
      securityLevel: relationalStore.SecurityLevel.S1
    }
    
    this.store = await relationalStore.getRdbStore(context, config)
    await this.createTables()
  }
  
  async createTables() {
    // åˆ›å»ºç¬”è®°è¡¨
    const sqlCreateNotes = `
      CREATE TABLE IF NOT EXISTS notes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        content TEXT,
        category_id INTEGER,
        created_at INTEGER,
        updated_at INTEGER,
        FOREIGN KEY (category_id) REFERENCES categories(id)
      )
    `
    
    // åˆ›å»ºåˆ†ç±»è¡¨
    const sqlCreateCategories = `
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        color TEXT
      )
    `
    
    await this.store.executeSql(sqlCreateNotes)
    await this.store.executeSql(sqlCreateCategories)
  }
  
  // æ·»åŠ ç¬”è®°
  async addNote(note: { title: string, content: string, categoryId?: number }) {
    const valueBucket = {
      title: note.title,
      content: note.content,
      category_id: note.categoryId || null,
      created_at: Date.now(),
      updated_at: Date.now()
    }
    
    return await this.store.insert('notes', valueBucket)
  }
  
  // è·å–æ‰€æœ‰ç¬”è®°
  async getAllNotes() {
    const predicates = new relationalStore.RdbPredicates('notes')
    predicates.orderByDesc('updated_at')
    
    const resultSet = await this.store.query(predicates)
    const notes = []
    
    while (resultSet.goToNextRow()) {
      notes.push({
        id: resultSet.getLong(resultSet.getColumnIndex('id')),
        title: resultSet.getString(resultSet.getColumnIndex('title')),
        content: resultSet.getString(resultSet.getColumnIndex('content')),
        categoryId: resultSet.getLong(resultSet.getColumnIndex('category_id')),
        createdAt: resultSet.getLong(resultSet.getColumnIndex('created_at')),
        updatedAt: resultSet.getLong(resultSet.getColumnIndex('updated_at'))
      })
    }
    
    resultSet.close()
    return notes
  }
  
  // æŒ‰åˆ†ç±»è·å–ç¬”è®°
  async getNotesByCategory(categoryId: number) {
    const predicates = new relationalStore.RdbPredicates('notes')
    predicates.equalTo('category_id', categoryId)
    predicates.orderByDesc('updated_at')
    
    const resultSet = await this.store.query(predicates)
    // ... å¤„ç†ç»“æœ
    resultSet.close()
  }
  
  // æœç´¢ç¬”è®°
  async searchNotes(keyword: string) {
    const predicates = new relationalStore.RdbPredicates('notes')
    predicates.like('title', `%${keyword}%`)
      .or()
      .like('content', `%${keyword}%`)
    
    const resultSet = await this.store.query(predicates)
    // ... å¤„ç†ç»“æœ
    resultSet.close()
  }
  
  // æ›´æ–°ç¬”è®°
  async updateNote(id: number, updates: { title?: string, content?: string }) {
    const valueBucket = {
      ...updates,
      updated_at: Date.now()
    }
    
    const predicates = new relationalStore.RdbPredicates('notes')
    predicates.equalTo('id', id)
    
    return await this.store.update(valueBucket, predicates)
  }
  
  // åˆ é™¤ç¬”è®°
  async deleteNote(id: number) {
    const predicates = new relationalStore.RdbPredicates('notes')
    predicates.equalTo('id', id)
    
    return await this.store.delete(predicates)
  }
  
  // æ·»åŠ åˆ†ç±»
  async addCategory(name: string, color: string) {
    const valueBucket = {
      name: name,
      color: color
    }
    
    return await this.store.insert('categories', valueBucket)
  }
  
  // è·å–æ‰€æœ‰åˆ†ç±»
  async getAllCategories() {
    const predicates = new relationalStore.RdbPredicates('categories')
    const resultSet = await this.store.query(predicates)
    
    const categories = []
    while (resultSet.goToNextRow()) {
      categories.push({
        id: resultSet.getLong(resultSet.getColumnIndex('id')),
        name: resultSet.getString(resultSet.getColumnIndex('name')),
        color: resultSet.getString(resultSet.getColumnIndex('color'))
      })
    }
    
    resultSet.close()
    return categories
  }
}

// ä½¿ç”¨
@Entry
@Component
struct NotesApp {
  private notesDb: NotesDatabase = new NotesDatabase()
  @State notes: Note[] = []
  
  async aboutToAppear() {
    await this.notesDb.init(getContext(this))
    await this.loadNotes()
  }
  
  async loadNotes() {
    this.notes = await this.notesDb.getAllNotes()
  }
  
  async addNote() {
    const id = await this.notesDb.addNote({
      title: 'æ–°ç¬”è®°',
      content: 'ç¬”è®°å†…å®¹'
    })
    
    await this.loadNotes()
  }
  
  build() {
    Column() {
      List() {
        ForEach(this.notes, (note: Note) => {
          ListItem() {
            Text(note.title)
          }
        })
      }
      
      Button('æ·»åŠ ç¬”è®°')
        .onClick(() => {
          this.addNote()
        })
    }
  }
}
```

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä½¿ç”¨äº‹åŠ¡

```typescript
await store.beginTransaction()
try {
  await store.insert('users', user1)
  await store.insert('users', user2)
  await store.commit()
} catch (err) {
  await store.rollback()
  console.error('äº‹åŠ¡å¤±è´¥:', err)
}
```

### 2. åŠæ—¶å…³é—­ ResultSet

```typescript
// âœ… ä½¿ç”¨å®Œç«‹å³å…³é—­
const resultSet = await store.query(predicates)
// å¤„ç†æ•°æ®
resultSet.close()

// âŒ å¿˜è®°å…³é—­ä¼šå¯¼è‡´å†…å­˜æ³„æ¼
```

### 3. ä½¿ç”¨ç´¢å¼•

```typescript
// åˆ›å»ºç´¢å¼•æé«˜æŸ¥è¯¢æ€§èƒ½
const sqlCreateIndex = `
  CREATE INDEX IF NOT EXISTS idx_email ON users(email)
`
await store.executeSql(sqlCreateIndex)
```

## ğŸ“š å‚è€ƒèµ„æº

- [RDB å®˜æ–¹æ–‡æ¡£](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-data-relationalstore-0000001820880609-V5)

---

**ä¸‹ä¸€èŠ‚** â†’ [åˆ†å¸ƒå¼æ•°æ®æœåŠ¡](03-åˆ†å¸ƒå¼æ•°æ®æœåŠ¡.md)
