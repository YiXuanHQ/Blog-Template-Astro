---
title: éŸ³é¢‘æ’­æ”¾ä¸å½•åˆ¶
date: 2025-01-22
nextChapter: "harmonyos-dev/12-multimedia-next/02-è§†é¢‘æ’­æ”¾ä¸å¤„ç†"
parentChapter: "harmonyos-dev/12-multimedia-next/README"
---
# éŸ³é¢‘æ’­æ”¾ä¸å½•åˆ¶

> å®ç°éŸ³é¢‘æ’­æ”¾å’Œå½•åˆ¶åŠŸèƒ½

## ğŸµ éŸ³é¢‘æ’­æ”¾

### AVPlayer æ’­æ”¾éŸ³é¢‘

```typescript
import { media } from '@kit.MediaKit'
import { BusinessError } from '@kit.BasicServicesKit'

@Entry
@Component
struct AudioPlayer {
  private avPlayer: media.AVPlayer | undefined
  @State isPlaying: boolean = false
  @State duration: number = 0
  @State currentTime: number = 0
  
  async aboutToAppear() {
    await this.initPlayer()
  }
  
  async initPlayer() {
    try {
      this.avPlayer = await media.createAVPlayer()
      
      // ç›‘å¬çŠ¶æ€å˜åŒ–
      this.avPlayer.on('stateChange', (state) => {
        console.log('çŠ¶æ€:', state)
      })
      
      // ç›‘å¬æ—¶é•¿
      this.avPlayer.on('durationUpdate', (duration) => {
        this.duration = duration
      })
      
      // ç›‘å¬æ’­æ”¾è¿›åº¦
      this.avPlayer.on('timeUpdate', (time) => {
        this.currentTime = time
      })
      
      // è®¾ç½®éŸ³é¢‘æº
      this.avPlayer.url = 'https://example.com/audio.mp3'
      // æˆ–æœ¬åœ°æ–‡ä»¶
      // this.avPlayer.fdSrc = { fd: fileFd }
      
    } catch (err) {
      console.error('åˆå§‹åŒ–å¤±è´¥:', err)
    }
  }
  
  async play() {
    if (this.avPlayer) {
      await this.avPlayer.play()
      this.isPlaying = true
    }
  }
  
  async pause() {
    if (this.avPlayer) {
      await this.avPlayer.pause()
      this.isPlaying = false
    }
  }
  
  async stop() {
    if (this.avPlayer) {
      await this.avPlayer.stop()
      this.isPlaying = false
      this.currentTime = 0
    }
  }
  
  async seek(time: number) {
    if (this.avPlayer) {
      await this.avPlayer.seek(time)
    }
  }
  
  formatTime(ms: number): string {
    const seconds = Math.floor(ms / 1000)
    const min = Math.floor(seconds / 60)
    const sec = seconds % 60
    return `${min}:${sec.toString().padStart(2, '0')}`
  }
  
  build() {
    Column({ space: 20 }) {
      Text('éŸ³é¢‘æ’­æ”¾å™¨')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
      
      // è¿›åº¦æ¡
      Row() {
        Text(this.formatTime(this.currentTime))
          .fontSize(14)
        
        Slider({
          value: this.currentTime,
          min: 0,
          max: this.duration,
          step: 1000
        })
        .layoutWeight(1)
        .onChange((value) => {
          this.seek(value)
        })
        
        Text(this.formatTime(this.duration))
          .fontSize(14)
      }
      .width('100%')
      
      // æ§åˆ¶æŒ‰é’®
      Row({ space: 20 }) {
        Button('æ’­æ”¾')
          .onClick(() => {
            this.play()
          })
          .enabled(!this.isPlaying)
        
        Button('æš‚åœ')
          .onClick(() => {
            this.pause()
          })
          .enabled(this.isPlaying)
        
        Button('åœæ­¢')
          .onClick(() => {
            this.stop()
          })
      }
    }
    .width('100%')
    .padding(20)
  }
  
  aboutToDisappear() {
    if (this.avPlayer) {
      this.avPlayer.release()
    }
  }
}
```

## ğŸ¤ éŸ³é¢‘å½•åˆ¶

### AVRecorder å½•éŸ³

```typescript
import { media } from '@kit.MediaKit'
import { fileIo } from '@kit.CoreFileKit'

@Entry
@Component
struct AudioRecorder {
  private avRecorder: media.AVRecorder | undefined
  @State isRecording: boolean = false
  @State recordTime: number = 0
  private timer: number = -1
  
  async aboutToAppear() {
    await this.initRecorder()
  }
  
  async initRecorder() {
    try {
      this.avRecorder = await media.createAVRecorder()
      
      // ç›‘å¬çŠ¶æ€
      this.avRecorder.on('stateChange', (state) => {
        console.log('å½•åˆ¶çŠ¶æ€:', state)
      })
      
      // ç›‘å¬é”™è¯¯
      this.avRecorder.on('error', (err) => {
        console.error('å½•åˆ¶é”™è¯¯:', err)
      })
      
    } catch (err) {
      console.error('åˆå§‹åŒ–å½•åˆ¶å™¨å¤±è´¥:', err)
    }
  }
  
  async startRecord() {
    if (!this.avRecorder) return
    
    try {
      // é…ç½®å½•éŸ³å‚æ•°
      const config: media.AVRecorderConfig = {
        audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,
        profile: {
          audioBitrate: 48000,
          audioChannels: 2,
          audioCodec: media.CodecMimeType.AUDIO_AAC,
          audioSampleRate: 48000,
          fileFormat: media.ContainerFormatType.CFT_MPEG_4A
        },
        url: 'fd://' + await this.getFd(),
        rotation: 0
      }
      
      await this.avRecorder.prepare(config)
      await this.avRecorder.start()
      
      this.isRecording = true
      this.startTimer()
      
    } catch (err) {
      console.error('å¼€å§‹å½•åˆ¶å¤±è´¥:', err)
    }
  }
  
  async stopRecord() {
    if (!this.avRecorder) return
    
    try {
      await this.avRecorder.stop()
      await this.avRecorder.release()
      
      this.isRecording = false
      this.stopTimer()
      this.recordTime = 0
      
      // é‡æ–°åˆå§‹åŒ–
      await this.initRecorder()
      
    } catch (err) {
      console.error('åœæ­¢å½•åˆ¶å¤±è´¥:', err)
    }
  }
  
  async getFd(): Promise<number> {
    const context = getContext(this)
    const filesDir = context.filesDir
    const filePath = filesDir + '/recording.m4a'
    
    const file = fileIo.openSync(filePath, fileIo.OpenMode.CREATE | fileIo.OpenMode.READ_WRITE)
    return file.fd
  }
  
  startTimer() {
    this.timer = setInterval(() => {
      this.recordTime++
    }, 1000)
  }
  
  stopTimer() {
    if (this.timer >= 0) {
      clearInterval(this.timer)
      this.timer = -1
    }
  }
  
  formatTime(seconds: number): string {
    const min = Math.floor(seconds / 60)
    const sec = seconds % 60
    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
  }
  
  build() {
    Column({ space: 30 }) {
      Text('éŸ³é¢‘å½•åˆ¶')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
      
      // å½•åˆ¶çŠ¶æ€
      Column({ space: 10 }) {
        Text(this.isRecording ? 'å½•åˆ¶ä¸­...' : 'æœªå½•åˆ¶')
          .fontSize(18)
          .fontColor(this.isRecording ? Color.Red : Color.Gray)
        
        Text(this.formatTime(this.recordTime))
          .fontSize(48)
          .fontWeight(FontWeight.Bold)
      }
      
      // æ§åˆ¶æŒ‰é’®
      Row({ space: 20 }) {
        Button('å¼€å§‹å½•åˆ¶')
          .width(120)
          .onClick(() => {
            this.startRecord()
          })
          .enabled(!this.isRecording)
        
        Button('åœæ­¢å½•åˆ¶')
          .width(120)
          .backgroundColor(Color.Red)
          .onClick(() => {
            this.stopRecord()
          })
          .enabled(this.isRecording)
      }
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
  
  aboutToDisappear() {
    this.stopTimer()
    if (this.avRecorder) {
      this.avRecorder.release()
    }
  }
}
```

## ğŸ¼ éŸ³é¢‘ç„¦ç‚¹ç®¡ç†

### å¤„ç†éŸ³é¢‘ç„¦ç‚¹

```typescript
import { audio } from '@kit.AudioKit'

class AudioFocusManager {
  private audioManager: audio.AudioManager
  private interruptMode: audio.InterruptMode = audio.InterruptMode.SHARE_MODE
  
  constructor() {
    this.audioManager = audio.getAudioManager()
  }
  
  // è¯·æ±‚éŸ³é¢‘ç„¦ç‚¹
  async requestFocus() {
    try {
      await this.audioManager.requestAudioFocus({
        streamUsage: audio.StreamUsage.STREAM_USAGE_MEDIA,
        interruptMode: this.interruptMode
      })
      console.log('è·å–éŸ³é¢‘ç„¦ç‚¹æˆåŠŸ')
    } catch (err) {
      console.error('è¯·æ±‚éŸ³é¢‘ç„¦ç‚¹å¤±è´¥:', err)
    }
  }
  
  // é‡Šæ”¾éŸ³é¢‘ç„¦ç‚¹
  async abandonFocus() {
    try {
      await this.audioManager.abandonAudioFocus({
        streamUsage: audio.StreamUsage.STREAM_USAGE_MEDIA
      })
      console.log('é‡Šæ”¾éŸ³é¢‘ç„¦ç‚¹æˆåŠŸ')
    } catch (err) {
      console.error('é‡Šæ”¾éŸ³é¢‘ç„¦ç‚¹å¤±è´¥:', err)
    }
  }
  
  // ç›‘å¬éŸ³é¢‘ä¸­æ–­
  onAudioInterrupt(callback: (interruptEvent: audio.InterruptEvent) => void) {
    this.audioManager.on('audioInterrupt', callback)
  }
}

// ä½¿ç”¨
@Entry
@Component
struct AudioFocusDemo {
  private focusManager: AudioFocusManager = new AudioFocusManager()
  
  aboutToAppear() {
    // è¯·æ±‚ç„¦ç‚¹
    this.focusManager.requestFocus()
    
    // ç›‘å¬ä¸­æ–­
    this.focusManager.onAudioInterrupt((event) => {
      if (event.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {
        // å¼ºåˆ¶ä¸­æ–­ï¼Œæš‚åœæ’­æ”¾
        console.log('è¢«å¼ºåˆ¶ä¸­æ–­')
      }
    })
  }
  
  aboutToDisappear() {
    this.focusManager.abandonFocus()
  }
  
  build() {
    Column() {
      Text('éŸ³é¢‘ç„¦ç‚¹ç®¡ç†')
    }
  }
}
```

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. èµ„æºç®¡ç†

```typescript
// âœ… åŠæ—¶é‡Šæ”¾èµ„æº
aboutToDisappear() {
  if (this.avPlayer) {
    this.avPlayer.release()
  }
}
```

### 2. é”™è¯¯å¤„ç†

```typescript
try {
  await this.avPlayer.play()
} catch (err) {
  const error = err as BusinessError
  if (error.code === 5400102) {
    console.error('æ’­æ”¾æ“ä½œä¸å…è®¸')
  }
}
```

### 3. æƒé™ç”³è¯·

```json5
// module.json5
{
  "requestPermissions": [
    {
      "name": "ohos.permission.MICROPHONE",
      "reason": "ç”¨äºå½•éŸ³",
      "usedScene": {
        "when": "inuse"
      }
    }
  ]
}
```

## ğŸ“š å‚è€ƒèµ„æº

- [éŸ³é¢‘æ’­æ”¾](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/audio-playback-overview-0000001820880689-V5)
- [éŸ³é¢‘å½•åˆ¶](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/audio-recording-overview-0000001774280838-V5)
- [AVPlayer API](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-media-0000001821000377-V5)

---

**ä¸‹ä¸€èŠ‚** â†’ [è§†é¢‘æ’­æ”¾ä¸å¤„ç†](02-è§†é¢‘æ’­æ”¾ä¸å¤„ç†.md)
