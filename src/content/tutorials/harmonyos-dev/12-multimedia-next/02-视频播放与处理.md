---
title: è§†é¢‘æ’­æ”¾ä¸å¤„ç†
date: 2025-01-22
prevChapter: "harmonyos-dev/12-multimedia-next/01-éŸ³é¢‘æ’­æ”¾ä¸å½•åˆ¶"
nextChapter: "harmonyos-dev/12-multimedia-next/03-ç›¸æœºå¼€å‘"
parentChapter: "harmonyos-dev/12-multimedia-next/README"
---
# è§†é¢‘æ’­æ”¾ä¸å¤„ç†

> å®ç°è§†é¢‘æ’­æ”¾å’Œå½•åˆ¶åŠŸèƒ½

## ğŸ¬ è§†é¢‘æ’­æ”¾

### Video ç»„ä»¶

```typescript
@Entry
@Component
struct VideoPlayerDemo {
  private videoController: VideoController = new VideoController()
  @State isPlaying: boolean = false
  @State currentTime: number = 0
  @State duration: number = 0
  
  build() {
    Column() {
      // è§†é¢‘æ’­æ”¾å™¨
      Video({
        src: 'https://example.com/video.mp4',
        controller: this.videoController
      })
      .width('100%')
      .height(300)
      .controls(true)
      .autoPlay(false)
      .onStart(() => {
        console.log('å¼€å§‹æ’­æ”¾')
        this.isPlaying = true
      })
      .onPause(() => {
        console.log('æš‚åœæ’­æ”¾')
        this.isPlaying = false
      })
      .onFinish(() => {
        console.log('æ’­æ”¾å®Œæˆ')
        this.isPlaying = false
      })
      .onError(() => {
        console.error('æ’­æ”¾é”™è¯¯')
      })
      .onPrepared((duration) => {
        this.duration = duration
        console.log('å‡†å¤‡å®Œæˆï¼Œæ—¶é•¿:', duration)
      })
      .onUpdate((event) => {
        this.currentTime = event.time
      })
      
      // æ§åˆ¶æ 
      Row({ space: 20 }) {
        Button('æ’­æ”¾')
          .onClick(() => {
            this.videoController.start()
          })
          .enabled(!this.isPlaying)
        
        Button('æš‚åœ')
          .onClick(() => {
            this.videoController.pause()
          })
          .enabled(this.isPlaying)
        
        Button('åœæ­¢')
          .onClick(() => {
            this.videoController.stop()
          })
      }
      .margin({ top: 20 })
      
      // è¿›åº¦ä¿¡æ¯
      Text(`${this.formatTime(this.currentTime)} / ${this.formatTime(this.duration)}`)
        .margin({ top: 10 })
    }
    .padding(20)
  }
  
  formatTime(ms: number): string {
    const seconds = Math.floor(ms / 1000)
    const min = Math.floor(seconds / 60)
    const sec = seconds % 60
    return `${min}:${sec.toString().padStart(2, '0')}`
  }
}
```

### AVPlayer é«˜çº§æ’­æ”¾

```typescript
import { media } from '@kit.MediaKit'

@Entry
@Component
struct AdvancedVideoPlayer {
  private avPlayer: media.AVPlayer | undefined
  @State surfaceId: string = ''
  private xComponentController: XComponentController = new XComponentController()
  
  async aboutToAppear() {
    await this.initPlayer()
  }
  
  async initPlayer() {
    try {
      this.avPlayer = await media.createAVPlayer()
      
      // è®¾ç½®è§†é¢‘æº
      this.avPlayer.url = 'https://example.com/video.mp4'
      
      // ç›‘å¬çŠ¶æ€
      this.avPlayer.on('stateChange', (state) => {
        console.log('æ’­æ”¾å™¨çŠ¶æ€:', state)
        
        if (state === 'prepared') {
          // è®¾ç½®æ˜¾ç¤ºçª—å£
          this.avPlayer!.surfaceId = this.surfaceId
        }
      })
      
      // ç›‘å¬è§†é¢‘å°ºå¯¸
      this.avPlayer.on('videoSizeChange', (width, height) => {
        console.log(`è§†é¢‘å°ºå¯¸: ${width}x${height}`)
      })
      
    } catch (err) {
      console.error('åˆå§‹åŒ–æ’­æ”¾å™¨å¤±è´¥:', err)
    }
  }
  
  build() {
    Column() {
      // XComponent ä½œä¸ºè§†é¢‘æ˜¾ç¤ºçª—å£
      XComponent({
        id: 'video_player',
        type: 'surface',
        controller: this.xComponentController
      })
      .width('100%')
      .height(300)
      .onLoad(() => {
        this.surfaceId = this.xComponentController.getXComponentSurfaceId()
      })
      
      Row({ space: 15 }) {
        Button('æ’­æ”¾')
          .onClick(() => {
            this.avPlayer?.play()
          })
        
        Button('æš‚åœ')
          .onClick(() => {
            this.avPlayer?.pause()
          })
        
        Button('è·³è½¬åˆ°30ç§’')
          .onClick(() => {
            this.avPlayer?.seek(30000)
          })
      }
      .margin({ top: 20 })
    }
    .padding(20)
  }
  
  aboutToDisappear() {
    if (this.avPlayer) {
      this.avPlayer.release()
    }
  }
}
```

## ğŸ“¹ è§†é¢‘å½•åˆ¶

### AVRecorder å½•åˆ¶è§†é¢‘

```typescript
import { media } from '@kit.MediaKit'
import { camera } from '@kit.CameraKit'

@Entry
@Component
struct VideoRecorder {
  private avRecorder: media.AVRecorder | undefined
  private cameraManager: camera.CameraManager | undefined
  @State isRecording: boolean = false
  @State recordTime: number = 0
  private timer: number = -1
  
  async startRecord() {
    try {
      this.avRecorder = await media.createAVRecorder()
      
      // é…ç½®å½•åˆ¶å‚æ•°
      const config: media.AVRecorderConfig = {
        audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,
        videoSourceType: media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_YUV,
        profile: {
          audioBitrate: 48000,
          audioChannels: 2,
          audioCodec: media.CodecMimeType.AUDIO_AAC,
          audioSampleRate: 48000,
          fileFormat: media.ContainerFormatType.CFT_MPEG_4,
          videoBitrate: 2000000,
          videoCodec: media.CodecMimeType.VIDEO_AVC,
          videoFrameWidth: 1920,
          videoFrameHeight: 1080,
          videoFrameRate: 30
        },
        url: 'fd://' + await this.getFd(),
        rotation: 0
      }
      
      await this.avRecorder.prepare(config)
      
      // è·å–å½•åˆ¶surface
      const surfaceId = await this.avRecorder.getInputSurface()
      
      // é…ç½®ç›¸æœºï¼ˆæ­¤å¤„ç®€åŒ–ï¼‰
      // å®é™…éœ€è¦å®Œæ•´çš„ç›¸æœºåˆå§‹åŒ–æµç¨‹
      
      await this.avRecorder.start()
      
      this.isRecording = true
      this.startTimer()
      
    } catch (err) {
      console.error('å¼€å§‹å½•åˆ¶å¤±è´¥:', err)
    }
  }
  
  async stopRecord() {
    if (this.avRecorder) {
      await this.avRecorder.stop()
      await this.avRecorder.release()
      
      this.isRecording = false
      this.stopTimer()
      this.recordTime = 0
    }
  }
  
  async getFd(): Promise<number> {
    // è·å–æ–‡ä»¶æè¿°ç¬¦
    return 0  // å®é™…å®ç°éœ€è¦æ‰“å¼€æ–‡ä»¶
  }
  
  startTimer() {
    this.timer = setInterval(() => {
      this.recordTime++
    }, 1000)
  }
  
  stopTimer() {
    if (this.timer >= 0) {
      clearInterval(this.timer)
    }
  }
  
  build() {
    Column({ space: 20 }) {
      Text('è§†é¢‘å½•åˆ¶')
        .fontSize(24)
      
      Text(this.formatTime(this.recordTime))
        .fontSize(36)
        .fontColor(this.isRecording ? Color.Red : Color.Black)
      
      Row({ space: 15 }) {
        Button('å¼€å§‹å½•åˆ¶')
          .onClick(() => {
            this.startRecord()
          })
          .enabled(!this.isRecording)
        
        Button('åœæ­¢å½•åˆ¶')
          .onClick(() => {
            this.stopRecord()
          })
          .enabled(this.isRecording)
      }
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
  
  formatTime(seconds: number): string {
    const min = Math.floor(seconds / 60)
    const sec = seconds % 60
    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
  }
}
```

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹ï¼šçŸ­è§†é¢‘æ’­æ”¾å™¨

```typescript
@Entry
@Component
struct ShortVideoPlayer {
  @State videoList: VideoInfo[] = [
    { id: 1, url: 'https://example.com/video1.mp4', title: 'è§†é¢‘1' },
    { id: 2, url: 'https://example.com/video2.mp4', title: 'è§†é¢‘2' },
    { id: 3, url: 'https://example.com/video3.mp4', title: 'è§†é¢‘3' }
  ]
  @State currentIndex: number = 0
  private swiperController: SwiperController = new SwiperController()
  
  build() {
    Stack() {
      // è§†é¢‘åˆ—è¡¨
      Swiper(this.swiperController) {
        ForEach(this.videoList, (video: VideoInfo, index: number) => {
          VideoItem({
            video: video,
            isActive: this.currentIndex === index
          })
        })
      }
      .width('100%')
      .height('100%')
      .vertical(true)
      .indicator(false)
      .onChange((index) => {
        this.currentIndex = index
      })
      
      // æ§åˆ¶æ 
      Column() {
        Blank()
        
        Row() {
          Text(this.videoList[this.currentIndex].title)
            .fontSize(18)
            .fontColor(Color.White)
        }
        .width('100%')
        .padding(20)
      }
      .width('100%')
      .height('100%')
    }
  }
}

@Component
struct VideoItem {
  @Prop video: VideoInfo
  @Prop isActive: boolean
  private videoController: VideoController = new VideoController()
  
  aboutToAppear() {
    if (this.isActive) {
      this.videoController.start()
    }
  }
  
  build() {
    Stack() {
      Video({
        src: this.video.url,
        controller: this.videoController
      })
      .width('100%')
      .height('100%')
      .objectFit(ImageFit.Cover)
      .controls(false)
      .autoPlay(this.isActive)
      .loop(true)
      .onClick(() => {
        if (this.isActive) {
          // åˆ‡æ¢æ’­æ”¾/æš‚åœ
        }
      })
    }
  }
}

interface VideoInfo {
  id: number
  url: string
  title: string
}
```

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. å†…å­˜ç®¡ç†

```typescript
// âœ… åŠæ—¶é‡Šæ”¾æ’­æ”¾å™¨
aboutToDisappear() {
  if (this.avPlayer) {
    this.avPlayer.release()
  }
}
```

### 2. é¢„åŠ è½½

```typescript
// é¢„åŠ è½½ä¸‹ä¸€ä¸ªè§†é¢‘
async preloadNext() {
  const nextVideo = this.videoList[this.currentIndex + 1]
  if (nextVideo) {
    // åˆ›å»ºé¢„åŠ è½½æ’­æ”¾å™¨
    const preloadPlayer = await media.createAVPlayer()
    preloadPlayer.url = nextVideo.url
  }
}
```

### 3. é”™è¯¯å¤„ç†

```typescript
.onError((error) => {
  console.error('æ’­æ”¾é”™è¯¯:', error)
  // æ˜¾ç¤ºé”™è¯¯æç¤º
  // å°è¯•é‡æ–°åŠ è½½
})
```

## ğŸ“š å‚è€ƒèµ„æº

- [è§†é¢‘æ’­æ”¾](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/video-playback-0000001774121010-V5)
- [è§†é¢‘å½•åˆ¶](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/video-recording-0000001820880741-V5)
- [Videoç»„ä»¶](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/ts-media-components-video-0000001815767544-V5)

---

**ä¸‹ä¸€èŠ‚** â†’ [ç›¸æœºå¼€å‘](03-ç›¸æœºå¼€å‘.md)
