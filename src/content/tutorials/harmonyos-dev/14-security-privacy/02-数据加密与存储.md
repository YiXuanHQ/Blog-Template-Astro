---
title: æ•°æ®åŠ å¯†ä¸å­˜å‚¨
date: 2025-01-22
prevChapter: "harmonyos-dev/14-security-privacy/01-æƒé™ç®¡ç†"
nextChapter: "harmonyos-dev/14-security-privacy/03-ç”Ÿç‰©è¯†åˆ«"
parentChapter: "harmonyos-dev/14-security-privacy/README"
---
# æ•°æ®åŠ å¯†ä¸å­˜å‚¨

> ä¿æŠ¤æ•æ„Ÿæ•°æ®å®‰å…¨

## ğŸ” æ•°æ®åŠ å¯†

### HUKS å¯†é’¥ç®¡ç†

```typescript
import { huks } from '@kit.UniversalKeystoreKit'

class EncryptionService {
  private keyAlias: string = 'user_data_key'
  
  // ç”Ÿæˆå¯†é’¥
  async generateKey() {
    const properties: huks.HuksOptions = {
      properties: [
        {
          tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
          value: huks.HuksKeyAlg.HUKS_ALG_AES
        },
        {
          tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
          value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PURPOSE,
          value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
                 huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
        }
      ]
    }
    
    try {
      await huks.generateKeyItem(this.keyAlias, properties)
      console.log('å¯†é’¥ç”ŸæˆæˆåŠŸ')
    } catch (err) {
      console.error('å¯†é’¥ç”Ÿæˆå¤±è´¥:', err)
    }
  }
  
  // åŠ å¯†æ•°æ®
  async encrypt(plainText: string): Promise<string> {
    const textEncoder = new util.TextEncoder()
    const plainData = textEncoder.encodeInto(plainText)
    
    const encryptOptions: huks.HuksOptions = {
      properties: [
        {
          tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
          value: huks.HuksKeyAlg.HUKS_ALG_AES
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PURPOSE,
          value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
        },
        {
          tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
          value: huks.HuksTagBlockMode.HUKS_TAG_BLOCK_MODE_CBC
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PADDING,
          value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7
        }
      ],
      inData: plainData
    }
    
    try {
      const handle = await huks.initSession(this.keyAlias, encryptOptions)
      const encrypted = await huks.finishSession(handle, encryptOptions)
      
      return this.arrayBufferToBase64(encrypted.outData!)
    } catch (err) {
      console.error('åŠ å¯†å¤±è´¥:', err)
      throw err
    }
  }
  
  // è§£å¯†æ•°æ®
  async decrypt(encryptedText: string): Promise<string> {
    const encryptedData = this.base64ToArrayBuffer(encryptedText)
    
    const decryptOptions: huks.HuksOptions = {
      properties: [
        {
          tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
          value: huks.HuksKeyAlg.HUKS_ALG_AES
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PURPOSE,
          value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
        },
        {
          tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
          value: huks.HuksTagBlockMode.HUKS_TAG_BLOCK_MODE_CBC
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PADDING,
          value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7
        }
      ],
      inData: encryptedData
    }
    
    try {
      const handle = await huks.initSession(this.keyAlias, decryptOptions)
      const decrypted = await huks.finishSession(handle, decryptOptions)
      
      const textDecoder = new util.TextDecoder()
      return textDecoder.decodeWithStream(decrypted.outData!)
    } catch (err) {
      console.error('è§£å¯†å¤±è´¥:', err)
      throw err
    }
  }
  
  // åˆ é™¤å¯†é’¥
  async deleteKey() {
    try {
      await huks.deleteKeyItem(this.keyAlias, {})
      console.log('å¯†é’¥åˆ é™¤æˆåŠŸ')
    } catch (err) {
      console.error('å¯†é’¥åˆ é™¤å¤±è´¥:', err)
    }
  }
  
  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer)
    let binary = ''
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }
    return btoa(binary)
  }
  
  private base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binary = atob(base64)
    const bytes = new Uint8Array(binary.length)
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i)
    }
    return bytes.buffer
  }
}
```

## ğŸ”’ å®‰å…¨å­˜å‚¨

### åŠ å¯†å­˜å‚¨ç”¨æˆ·æ•°æ®

```typescript
import { preferences } from '@kit.ArkData'

class SecureStorage {
  private prefs: preferences.Preferences | null = null
  private encryptionService: EncryptionService = new EncryptionService()
  
  async init(context: Context) {
    this.prefs = await preferences.getPreferences(context, 'secure_storage')
    await this.encryptionService.generateKey()
  }
  
  // å®‰å…¨ä¿å­˜æ•°æ®
  async secureSet(key: string, value: string) {
    if (!this.prefs) return
    
    try {
      // åŠ å¯†æ•°æ®
      const encrypted = await this.encryptionService.encrypt(value)
      
      // å­˜å‚¨
      await this.prefs.put(key, encrypted)
      await this.prefs.flush()
      
      console.log('æ•°æ®å®‰å…¨ä¿å­˜æˆåŠŸ')
    } catch (err) {
      console.error('å®‰å…¨ä¿å­˜å¤±è´¥:', err)
    }
  }
  
  // å®‰å…¨è¯»å–æ•°æ®
  async secureGet(key: string): Promise<string | null> {
    if (!this.prefs) return null
    
    try {
      // è¯»å–åŠ å¯†æ•°æ®
      const encrypted = await this.prefs.get(key, '') as string
      
      if (!encrypted) {
        return null
      }
      
      // è§£å¯†
      const decrypted = await this.encryptionService.decrypt(encrypted)
      return decrypted
    } catch (err) {
      console.error('å®‰å…¨è¯»å–å¤±è´¥:', err)
      return null
    }
  }
  
  // åˆ é™¤æ•°æ®
  async secureDelete(key: string) {
    if (!this.prefs) return
    
    try {
      await this.prefs.delete(key)
      await this.prefs.flush()
    } catch (err) {
      console.error('åˆ é™¤å¤±è´¥:', err)
    }
  }
}
```

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹ï¼šç”¨æˆ·å‡­è¯ç®¡ç†

```typescript
@Entry
@Component
struct LoginPage {
  private secureStorage: SecureStorage = new SecureStorage()
  @State username: string = ''
  @State password: string = ''
  @State rememberMe: boolean = false
  
  async aboutToAppear() {
    await this.secureStorage.init(getContext(this))
    await this.loadSavedCredentials()
  }
  
  async loadSavedCredentials() {
    try {
      const savedUsername = await this.secureStorage.secureGet('username')
      const savedPassword = await this.secureStorage.secureGet('password')
      
      if (savedUsername && savedPassword) {
        this.username = savedUsername
        this.password = savedPassword
        this.rememberMe = true
      }
    } catch (err) {
      console.error('åŠ è½½å‡­è¯å¤±è´¥:', err)
    }
  }
  
  async login() {
    if (!this.username || !this.password) {
      promptAction.showToast({ message: 'è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ' })
      return
    }
    
    try {
      // è°ƒç”¨ç™»å½•API
      const success = await this.performLogin(this.username, this.password)
      
      if (success) {
        // ä¿å­˜å‡­è¯
        if (this.rememberMe) {
          await this.secureStorage.secureSet('username', this.username)
          await this.secureStorage.secureSet('password', this.password)
        } else {
          // æ¸…é™¤ä¿å­˜çš„å‡­è¯
          await this.secureStorage.secureDelete('username')
          await this.secureStorage.secureDelete('password')
        }
        
        // è·³è½¬åˆ°é¦–é¡µ
        router.replaceUrl({ url: 'pages/Home' })
      } else {
        promptAction.showToast({ message: 'ç™»å½•å¤±è´¥' })
      }
    } catch (err) {
      console.error('ç™»å½•é”™è¯¯:', err)
    }
  }
  
  async performLogin(username: string, password: string): Promise<boolean> {
    // å®é™…çš„ç™»å½•é€»è¾‘
    return true
  }
  
  build() {
    Column({ space: 20 }) {
      Text('ç™»å½•')
        .fontSize(32)
        .fontWeight(FontWeight.Bold)
      
      TextInput({ placeholder: 'ç”¨æˆ·å' })
        .type(InputType.Normal)
        .onChange((value) => {
          this.username = value
        })
      
      TextInput({ placeholder: 'å¯†ç ' })
        .type(InputType.Password)
        .onChange((value) => {
          this.password = value
        })
      
      Row() {
        Checkbox()
          .select(this.rememberMe)
          .onChange((checked) => {
            this.rememberMe = checked
          })
        
        Text('è®°ä½å¯†ç ')
          .fontSize(14)
      }
      
      Button('ç™»å½•')
        .width('100%')
        .onClick(() => {
          this.login()
        })
    }
    .width('80%')
    .padding(20)
  }
}
```

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. æ•æ„Ÿæ•°æ®åŠ å¯†

```typescript
// âœ… åŠ å¯†å­˜å‚¨æ•æ„Ÿæ•°æ®
await secureStorage.secureSet('token', authToken)
await secureStorage.secureSet('password', userPassword)

// âŒ é¿å…æ˜æ–‡å­˜å‚¨
await prefs.put('token', authToken)  // ä¸å®‰å…¨
```

### 2. å¯†é’¥ç®¡ç†

```typescript
// âœ… ä½¿ç”¨ HUKS ç®¡ç†å¯†é’¥
const keyAlias = 'app_master_key'
await huks.generateKeyItem(keyAlias, options)

// âŒ é¿å…ç¡¬ç¼–ç å¯†é’¥
const KEY = 'hardcoded_key_123'  // ä¸å®‰å…¨
```

### 3. æ•°æ®æ¸…ç†

```typescript
// âœ… ç”¨æˆ·ç™»å‡ºæ—¶æ¸…ç†æ•æ„Ÿæ•°æ®
async logout() {
  await secureStorage.secureDelete('token')
  await secureStorage.secureDelete('userInfo')
  router.replaceUrl({ url: 'pages/Login' })
}
```

## ğŸ“š å‚è€ƒèµ„æº

- [é€šç”¨å¯†é’¥åº“](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/huks-guidelines-0000001821000685-V5)
- [æ•°æ®å®‰å…¨](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/data-security-protection-0000001774121022-V5)

---

**ä¸‹ä¸€èŠ‚** â†’ [ç”Ÿç‰©è¯†åˆ«](03-ç”Ÿç‰©è¯†åˆ«.md)
