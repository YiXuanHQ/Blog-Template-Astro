---
title: ---
---

---
title: 数据流管理
date: 2025-01-22
---

# 数据流管理

> 构建清晰的数据流向

## 🔄 单向数据流

### 概念

```
单向数据流
┌─────────────┐
│   State     │ 数据源
└──────┬──────┘
       ↓
┌─────────────┐
│     UI      │ 视图
└──────┬──────┘
       ↓
┌─────────────┐
│   Actions   │ 操作
└──────┬──────┘
       ↓
   Update State
```

### 实现

```typescript
// 数据模型
@ObservedV2
class TodoStore {
  @Trace items: TodoItem[] = []
  
  // 操作方法
  addItem(text: string) {
    this.items.push({
      id: Date.now(),
      text,
      done: false
    })
  }
  
  removeItem(id: number) {
    const index = this.items.findIndex(item => item.id === id)
    if (index >= 0) {
      this.items.splice(index, 1)
    }
  }
  
  toggleItem(id: number) {
    const item = this.items.find(i => i.id === id)
    if (item) {
      item.done = !item.done
    }
  }
}

// 视图组件
@Entry
@Component
struct TodoApp {
  @Local store: TodoStore = new TodoStore()
  @State newTodo: string = ''
  
  build() {
    Column() {
      // 输入
      Row() {
        TextInput({ text: this.newTodo })
          .onChange((value) => {
            this.newTodo = value
          })
        
        Button('添加')
          .onClick(() => {
            // Action → Update State
            this.store.addItem(this.newTodo)
            this.newTodo = ''
          })
      }
      
      // 列表渲染
      List() {
        ForEach(this.store.items, (item: TodoItem) => {
          ListItem() {
            Row() {
              Checkbox()
                .select(item.done)
                .onChange((checked) => {
                  // Action → Update State
                  this.store.toggleItem(item.id)
                })
              
              Text(item.text)
              
              Button('删除')
                .onClick(() => {
                  // Action → Update State
                  this.store.removeItem(item.id)
                })
            }
          }
        })
      }
    }
  }
}
```

## ⬆️⬇️ 双向数据绑定

### @Link 双向绑定

```typescript
// 父组件
@Entry
@Component
struct Parent {
  @State count: number = 0
  
  build() {
    Column() {
      Text(`Parent: ${this.count}`)
      
      // 使用 $ 传递引用
      Child({ count: $count })
    }
  }
}

// 子组件
@Component
struct Child {
  @Link count: number  // 双向绑定
  
  build() {
    Column() {
      Text(`Child: ${this.count}`)
      
      Button('子组件修改')
        .onClick(() => {
          this.count++  // 父组件也会更新
        })
    }
  }
}
```

### 表单双向绑定

```typescript
@Entry
@Component
struct FormExample {
  @State formData: FormData = {
    username: '',
    email: '',
    age: 0
  }
  
  build() {
    Column({ space: 15 }) {
      TextInput({ text: this.formData.username })
        .onChange((value) => {
          this.formData.username = value
        })
      
      TextInput({ text: this.formData.email })
        .onChange((value) => {
          this.formData.email = value
        })
      
      Counter({ value: $$(this.formData.age) })  // 双向绑定
      
      Button('提交')
        .onClick(() => {
          console.log('表单数据:', this.formData)
        })
    }
  }
}

@Component
struct Counter {
  @Link value: number
  
  build() {
    Row() {
      Button('-')
        .onClick(() => this.value--)
      Text(`${this.value}`)
      Button('+')
        .onClick(() => this.value++)
    }
  }
}
```

## 📤 状态提升

### 兄弟组件通信

```typescript
// 状态提升到父组件
@Entry
@Component
struct Parent {
  @State selectedId: number = 0  // 提升的状态
  
  build() {
    Column() {
      // 兄弟组件 A
      ProductList({
        selectedId: this.selectedId,
        onSelect: (id) => {
          this.selectedId = id
        }
      })
      
      // 兄弟组件 B
      ProductDetail({
        productId: this.selectedId
      })
    }
  }
}

@Component
struct ProductList {
  @Prop selectedId: number
  @Prop onSelect: (id: number) => void
  @State products: Product[] = []
  
  build() {
    List() {
      ForEach(this.products, (product: Product) => {
        ListItem() {
          Row() {
            Text(product.name)
          }
          .backgroundColor(this.selectedId === product.id ? Color.Blue : Color.White)
          .onClick(() => {
            this.onSelect(product.id)
          })
        }
      })
    }
  }
}

@Component
struct ProductDetail {
  @Prop productId: number
  @State product: Product = null
  
  aboutToAppear() {
    this.loadProduct(this.productId)
  }
  
  build() {
    Column() {
      if (this.product) {
        Text(this.product.name)
        Text(this.product.description)
      }
    }
  }
}
```

## 🎯 实战案例

### 购物车数据流

```typescript
// 1. 数据模型
@ObservedV2
class CartStore {
  @Trace items: CartItem[] = []
  
  get totalPrice(): number {
    return this.items.reduce((sum, item) => sum + item.price * item.quantity, 0)
  }
  
  get totalItems(): number {
    return this.items.reduce((sum, item) => sum + item.quantity, 0)
  }
  
  addItem(product: Product) {
    const existing = this.items.find(item => item.id === product.id)
    
    if (existing) {
      existing.quantity++
    } else {
      this.items.push({
        id: product.id,
        name: product.name,
        price: product.price,
        quantity: 1
      })
    }
  }
  
  removeItem(id: number) {
    const index = this.items.findIndex(item => item.id === id)
    if (index >= 0) {
      this.items.splice(index, 1)
    }
  }
  
  updateQuantity(id: number, quantity: number) {
    const item = this.items.find(i => i.id === id)
    if (item) {
      item.quantity = quantity
    }
  }
}

// 2. 商品列表页
@Entry
@Component
struct ProductList {
  @Provide('cart') cart: CartStore = new CartStore()
  @State products: Product[] = []
  
  build() {
    Column() {
      // 顶部购物车
      CartBadge()
      
      // 商品列表
      List() {
        ForEach(this.products, (product: Product) => {
          ListItem() {
            ProductItem({ product: product })
          }
        })
      }
    }
  }
}

// 3. 商品项组件
@Component
struct ProductItem {
  @Prop product: Product
  @Consume('cart') cart: CartStore
  
  build() {
    Row() {
      Image(this.product.image)
        .width(80)
        .height(80)
      
      Column({ space: 5 }) {
        Text(this.product.name)
          .fontSize(16)
        
        Text(`¥${this.product.price}`)
          .fontSize(18)
          .fontColor(Color.Red)
      }
      .layoutWeight(1)
      
      Button('加入购物车')
        .onClick(() => {
          this.cart.addItem(this.product)
        })
    }
    .padding(15)
  }
}

// 4. 购物车角标
@Component
struct CartBadge {
  @Consume('cart') cart: CartStore
  
  build() {
    Badge({
      value: `${this.cart.totalItems}`,
      position: BadgePosition.RightTop
    }) {
      Image($r('app.media.icon_cart'))
        .width(24)
        .height(24)
    }
  }
}

// 5. 购物车页面
@Entry
@Component
struct CartPage {
  @Provide('cart') cart: CartStore = new CartStore()
  
  build() {
    Column() {
      List() {
        ForEach(this.cart.items, (item: CartItem) => {
          ListItem() {
            CartItemView({ item: item })
          }
        })
      }
      
      // 底部结算
      Row() {
        Column({ space: 5 }) {
          Text(`共 ${this.cart.totalItems} 件`)
          Text(`¥${this.cart.totalPrice}`)
            .fontSize(20)
            .fontColor(Color.Red)
        }
        
        Button('结算')
          .width(120)
      }
      .padding(20)
    }
  }
}

@Component
struct CartItemView {
  @Prop item: CartItem
  @Consume('cart') cart: CartStore
  
  build() {
    Row() {
      Text(this.item.name)
        .layoutWeight(1)
      
      Row() {
        Button('-')
          .onClick(() => {
            if (this.item.quantity > 1) {
              this.cart.updateQuantity(this.item.id, this.item.quantity - 1)
            }
          })
        
        Text(`${this.item.quantity}`)
          .width(40)
          .textAlign(TextAlign.Center)
        
        Button('+')
          .onClick(() => {
            this.cart.updateQuantity(this.item.id, this.item.quantity + 1)
          })
      }
      
      Button('删除')
        .onClick(() => {
          this.cart.removeItem(this.item.id)
        })
    }
  }
}
```

## 💡 最佳实践

### 1. 保持数据流清晰

```typescript
// ✅ 单向数据流
State → View → Actions → Update State

// ❌ 避免双向混乱
View ↔ State ↔ View
```

### 2. 合理使用双向绑定

```typescript
// ✅ 表单输入使用双向绑定
TextInput({ text: $username })

// ❌ 避免过度使用
// 复杂数据仍然使用单向流
```

### 3. 状态提升原则

```typescript
// ✅ 共享状态提升到最近公共父组件
Parent (state)
├─ ChildA (使用state)
└─ ChildB (使用state)

// ❌ 避免过度提升
Root (state) → 太高层级
└─ ... many levels
    └─ DeepChild (使用state)
```

## 📚 参考资源

- [状态管理官方文档](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-state-management-0000001524537145-V3)

---

**第4章完成！** 继续学习 → [第5章：Ability 框架升级](../05-ability-framework/)
