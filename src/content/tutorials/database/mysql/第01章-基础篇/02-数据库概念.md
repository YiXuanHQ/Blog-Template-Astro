---
title: 数据库概念
prevChapter: "java-backend/mysql/第01章-基础篇/01-概述与安装"
nextChapter: "java-backend/mysql/第01章-基础篇/03-SQL基础语法"
parentChapter: "java-backend/mysql/README"
---
# 数据库概念

> 本章将深入介绍数据库的核心概念、设计规范以及函数依赖理论，为数据库设计打下坚实的理论基础。

## ⚡ 快速参考

- **核心术语**：表、字段、记录、主键、外键、索引、视图、触发器、事务、存储过程
- **数据库范式**：1NF（原子性）、2NF（消除部分依赖）、3NF（消除传递依赖）、BCNF
- **函数依赖**：完全依赖、部分依赖、传递依赖
- **关系连接**：自然连接、引用完整性（外键约束）
- **Armstrong公理**：自反律、增广律、传递律

## 📚 学习目标

1. 掌握数据库核心术语的含义和应用场景
2. 理解数据库范式理论，能够识别和设计符合范式的表结构
3. 学会分析函数依赖关系，识别完全依赖、部分依赖和传递依赖
4. 理解关系连接的概念，掌握外键约束的使用方法
5. 为后续数据库设计和SQL学习打下坚实的理论基础

## 一、数据库核心术语

理解这些核心术语是学习数据库的基础：

### 1.1 表（Table）

**表**是数据库中存储数据的基本单位，由行和列组成。每个表代表一个实体集，如学生表、员工表等。

**示例：员工表（employees）**

| id | name | age | department |
|----|------|-----|------------|
|  1 | 张三 |  28 | 技术部     |
|  2 | 李四 |  32 | 销售部     |
|  3 | 王五 |  25 | 技术部     |

### 1.2 字段/列（Field/Column）

**字段（列）**是表中的一列，代表一种属性。例如：在上面的员工表中，`id`、`name`、`age`、`department` 都是字段。

### 1.3 记录/行（Record/Row）

**记录（行）**是表中的一行，包含一个实体的完整信息。例如：`1, 张三, 28, 技术部` 是一条完整的员工记录。

### 1.4 主键（Primary Key）

主键用来唯一标识表中的每条记录，具有以下特点：

- ✅ 唯一性：每条记录的主键值必须唯一
- ✅ 非空性：主键值不能为NULL
- ✅ 不可变性：主键值一旦设定，通常不应修改

```sql
-- 定义主键
CREATE TABLE students (
    student_id INT PRIMARY KEY,  -- 主键
    name VARCHAR(50),
    age INT
);
```

### 1.5 外键（Foreign Key）

**外键**是一个表中的字段，它引用另一个表的主键，用于建立表之间的关系，确保数据的引用完整性。

```sql
-- 订单表引用客户表
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

### 1.6 索引（Index）

**索引**是一种特殊的数据结构，用于加快数据检索速度，就像书籍的目录。

**优缺点：**
- 📈 **优点**：大幅提高查询效率
- 📉 **缺点**：增加写入开销（INSERT、UPDATE、DELETE操作变慢）
- 💾 **缺点**：占用额外存储空间

### 1.7 视图（View）

**视图**是从一个或多个表中导出的虚拟表，不存储实际数据，只保存查询逻辑。每次查询视图时，数据库会执行相应的查询语句。

```sql
-- 创建视图
CREATE VIEW employee_summary AS
SELECT name, age, department 
FROM employees 
WHERE age > 25;
```

### 1.8 触发器（Trigger）

**触发器**是在特定事件（INSERT、UPDATE、DELETE）发生时自动执行的SQL语句集合。通常用于数据验证、审计日志等功能。

### 1.9 事务（Transaction）

**事务**是一组作为整体执行的数据库操作，具有ACID特性：要么全部成功，要么全部失败（回滚）。

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- 提交事务
```

### 1.10 存储过程（Stored Procedure）

**存储过程**是预编译的SQL语句集合，可以接受参数，执行复杂的业务逻辑。存储在数据库中，可以被多次调用，提高执行效率。

---

## 二、数据库设计规范

### 2.1 数据库范式

**数据库范式**是设计关系型数据库时应遵循的规则，目的是减少数据冗余，提高数据一致性，避免数据异常。

#### 第一范式（1NF）

**定义**：每个字段都不可再分，是原子性的（不能再分解）。

❌ **不符合1NF的表：**

| 学号 | 姓名 | 联系方式              |
|------|------|----------------------|
| 001  | 张三 | 13800138000, 北京市   |

**问题**：联系方式字段包含了电话和地址两个信息，不符合原子性要求。

✅ **符合1NF的表：**

| 学号 | 姓名 | 电话        | 地址   |
|------|------|-------------|-------|
| 001  | 张三 | 13800138000 | 北京市 |

**改进**：将联系方式拆分为电话和地址两个独立字段。

#### 第二范式（2NF）

**定义**：在1NF基础上，非主属性完全依赖于主键（消除部分依赖）。即：所有非主属性都必须完全依赖于整个主键，而不能只依赖于主键的一部分。

❌ **不符合2NF的表**（学号和课程号是联合主键）：

| 学号 | 课程号 | 姓名 | 课程名 | 成绩 |
|------|--------|------|--------|------|
| 001  | 1001   | 张三 | 数学   | 90   |
| 001  | 1002   | 张三 | 英语   | 85   |

**问题**：
- 姓名只依赖于学号（主键的一部分）
- 课程名只依赖于课程号（主键的一部分）
- 只有成绩完全依赖于（学号, 课程号）这个联合主键

✅ **符合2NF的设计**：

**学生表：**
| 学号 | 姓名 |
|------|------|
| 001  | 张三 |

**课程表：**
| 课程号 | 课程名 |
|--------|--------|
| 1001   | 数学   |
| 1002   | 英语   |

**成绩表：**
| 学号 | 课程号 | 成绩 |
|------|--------|------|
| 001  | 1001   | 90   |
| 001  | 1002   | 85   |

**改进**：将表拆分为三个表，每个非主属性都完全依赖于各自的主键。

#### 第三范式（3NF）

**定义**：在2NF基础上，非主属性不依赖于其他非主属性（消除传递依赖）。即：非主属性之间不能有依赖关系。

❌ **不符合3NF的表**：

| 学号 | 姓名 | 系号 | 系名   |
|------|------|------|--------|
| 001  | 张三 | 01   | 计算机 |
| 002  | 李四 | 01   | 计算机 |

**问题**：
- 系名依赖于系号（非主属性）
- 系号依赖于学号（主键）
- 存在传递依赖：学号 → 系号 → 系名

✅ **符合3NF的设计**：

**学生表：**
| 学号 | 姓名 | 系号 |
|------|------|------|
| 001  | 张三 | 01   |
| 002  | 李四 | 01   |

**院系表：**
| 系号 | 系名   |
|------|--------|
| 01   | 计算机 |

**改进**：将系名从学生表中分离出来，消除传递依赖。

#### BCNF（Boyce-Codd范式）

**定义**：在3NF基础上，每个函数依赖的决定因素都包含键（候选键）。BCNF是3NF的增强版，消除了主属性对非主属性的依赖。

**特点**：
- 比3NF更严格
- 消除了所有数据冗余
- 但有时可能会影响查询性能（需要多表连接）

### 2.2 关系模式术语

- **关系模式**：对关系的逻辑结构和特征的描述
- **关系代数**：以关系作为运算对象的代数系统
- **元组**：关系中的一行（一条记录）
- **属性**：关系中的一列（一个字段）
- **主属性**：能唯一标识元组的属性
- **数据冗余**：同一数据在多处重复存储

---

## 三、函数依赖理论

### 3.1 什么是函数依赖？

在关系模式R中，如果属性X的值能唯一确定属性Y的值，则称Y函数依赖于X，记作：**X → Y**

**举例**：
- `学号 → 姓名`（学号确定，姓名就确定）
- `学号 → 专业`（学号确定，专业就确定）
- `(学号, 课程号) → 成绩`（学号和课程号共同确定成绩）

### 3.2 函数依赖的类型

#### 完全函数依赖

如果 X → Y，且不存在X的真子集X'使得X' → Y，则Y完全函数依赖于X。

**示例**：

```
(学号, 课程号) → 成绩  ✅ 完全依赖
```

**说明**：不能通过单独的学号或课程号确定成绩，必须同时知道学号和课程号才能唯一确定成绩。

#### 部分函数依赖

如果 X → Y，但存在X的真子集X'使得X' → Y，则Y**部分函数依赖**于X。

**示例**：

```
(学号, 课程号) → 姓名  ❌ 部分依赖
```

**说明**：因为 `学号 → 姓名`（只需学号就能确定姓名），所以姓名只依赖于主键的一部分，这就是部分依赖。

#### 传递函数依赖

如果 X → Y，Y → Z，且Y不是X的子集，Y不函数依赖于X，则Z**传递函数依赖**于X。

**示例**：

```
学号 → 系号
系号 → 系主任
因此：学号 → 系主任（传递依赖）
```

**说明**：系主任通过系号间接依赖于学号，存在中间传递关系。

### 3.3 函数依赖的性质（Armstrong公理）

Armstrong公理是函数依赖推理的基础，包含三个基本规则和三个推理规则。

**基本规则：**

1. **自反律**：如果 Y ⊆ X，则 X → Y（平凡依赖）
2. **增广律**：如果 X → Y，则 XZ → YZ（在左右两边同时添加属性）
3. **传递律**：如果 X → Y 且 Y → Z，则 X → Z（传递依赖）

**推理规则：**

1. **合并规则**：如果 X → Y 且 X → Z，则 X → YZ
2. **分解规则**：如果 X → YZ，则 X → Y 且 X → Z
3. **伪传递规则**：如果 X → Y 且 WY → Z，则 WX → Z

---

## 四、关系连接

### 4.1 自然连接（Natural Join）

**自然连接**会自动根据两个表中的同名列进行匹配，去除重复的列。

**示例：**

**员工表（employees）：**

| emp_id | name | dept_id |
|--------|------|---------|
| 1      | 张三 | 101     |
| 2      | 李四 | 102     |

**部门表（departments）：**

| dept_id | dept_name |
|---------|-----------|
| 101     | 技术部    |
| 102     | 销售部    |

**自然连接SQL：**

```sql
SELECT * FROM employees NATURAL JOIN departments;
```

**连接结果：**

| emp_id | name | dept_id | dept_name |
|--------|------|---------|-----------|
| 1      | 张三 | 101     | 技术部    |
| 2      | 李四 | 102     | 销售部    |

**特点：**
- ✅ 自动匹配同名列（`dept_id`）
- ✅ 简化查询语句，无需指定连接条件
- ⚠️ 需确保同名列含义相同，否则可能产生错误连接

### 4.2 引用完整性

**引用完整性**通过外键约束实现，确保表之间关系的一致性，防止无效数据的插入。

**示例：**

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON DELETE CASCADE      -- 删除客户时，级联删除订单
        ON UPDATE CASCADE      -- 更新客户ID时，级联更新订单
);
```

**外键约束选项：**

| 选项 | 说明 |
|------|------|
| `CASCADE` | 级联操作：删除/更新主表记录时，自动删除/更新从表记录 |
| `SET NULL` | 设置为NULL：删除/更新主表记录时，将从表外键设置为NULL |
| `RESTRICT` | 限制操作：如果从表有对应记录，禁止删除/更新主表记录 |
| `NO ACTION` | 不执行操作：同RESTRICT，但检查时机不同 |

---

## 五、本章总结

### 5.1 核心要点

1. **数据库核心术语**
   - **基础概念**：表、字段、记录
   - **约束机制**：主键、外键、索引
   - **高级特性**：视图、触发器、事务、存储过程

2. **数据库设计规范**
   - **范式理论**：1NF（原子性）、2NF（消除部分依赖）、3NF（消除传递依赖）、BCNF
   - **设计原则**：减少数据冗余，提高数据一致性，避免数据异常

3. **函数依赖理论**
   - **基本概念**：函数依赖、完全依赖、部分依赖、传递依赖
   - **推理规则**：Armstrong公理（自反律、增广律、传递律）

4. **关系连接**
   - **自然连接**：自动匹配同名列
   - **引用完整性**：通过外键约束保证数据一致性

### 5.2 学习建议

1. ✅ **理解核心术语**：熟练掌握表、字段、记录、主键、外键等基本概念
2. ✅ **掌握范式理论**：理解1NF、2NF、3NF的要求和设计原则
3. ✅ **学会识别依赖**：能够识别完全依赖、部分依赖、传递依赖
4. ✅ **实践设计规范**：在设计数据库时遵循范式要求，合理使用外键约束

### 5.3 下一步

在掌握了数据库的基础概念后，我们将在 **[第03章 - SQL基础语法](03-SQL基础语法.md)** 中学习如何使用SQL语句来操作数据库。

---

## 六、练习题

### 6.1 选择题

**1. 以下哪个不是关系型数据库？**

- A. MySQL
- B. MongoDB ✅ **（正确答案）**
- C. PostgreSQL
- D. Oracle

**2. ACID中的A代表什么？**

- A. Atomicity（原子性）✅ **（正确答案）**
- B. Availability（可用性）
- C. Authentication（认证）
- D. Authorization（授权）

**3. 第一范式（1NF）要求什么？**

- A. 每个字段都可以再分
- B. 每个字段都不可再分，是原子性的 ✅ **（正确答案）**
- C. 消除部分依赖
- D. 消除传递依赖

**4. 以下哪个是传递函数依赖的例子？**

- A. `学号 → 姓名`
- B. `(学号, 课程号) → 成绩`
- C. `学号 → 系号`，`系号 → 系主任`，因此 `学号 → 系主任` ✅ **（正确答案）**
- D. `学号 → 课程号`

### 6.2 思考题

1. **请解释为什么需要数据库范式？数据库范式的目的是什么？**
   - 提示：从数据冗余、数据一致性、数据异常等角度分析

2. **设计一个简单的图书管理系统，需要包含：图书、读者、借阅记录。请画出ER图并说明表之间的关系。**
   - 提示：考虑实体之间的关系（一对多、多对多等）
   - 确定每个表的主键和外键

3. **什么情况下应该使用关系型数据库？什么情况下应该使用非关系型数据库？**
   - 提示：从数据结构、一致性要求、扩展性、性能等角度分析

---

**上一章：** [概述与安装](/tutorials/java-backend/mysql/第01章-基础篇/01-概述与安装/)

**下一章：** [SQL基础语法](/tutorials/java-backend/mysql/第01章-基础篇/03-SQL基础语法/) →
