---
title: 数据完整性
prevChapter: "java-backend/mysql/第04章-实践篇/03-索引和视图"
nextChapter: "java-backend/mysql/第04章-实践篇/05-存储过程和存储函数"
parentChapter: "java-backend/mysql/README"
---
# 数据完整性

> 本章通过实际案例学习MySQL数据完整性的实现，包括主键约束、外键约束、唯一约束、检查约束等。掌握如何通过约束保证数据的正确性和一致性。

## ⚡ 快速参考

- **约束类型**：主键约束（PRIMARY KEY）、外键约束（FOREIGN KEY）、唯一约束（UNIQUE）、非空约束（NOT NULL）、默认约束（DEFAULT）、检查约束（CHECK）
- **约束操作**：创建约束、修改约束、删除约束
- **外键级联**：CASCADE（级联）、SET NULL（设为空）、RESTRICT（限制）、NO ACTION（无动作）
- **触发器**：BEFORE/AFTER INSERT/UPDATE/DELETE触发器
- **约束作用**：保证数据准确性、维护数据一致性、建立表间关系

## 📚 学习目标

1. 掌握各种约束类型的创建和管理方法
2. 理解主键约束和外键约束的作用和应用场景
3. 掌握外键约束的级联操作设置
4. 理解唯一约束、非空约束、默认约束的使用
5. 掌握检查约束的创建和使用（MySQL 8.0.16+）
6. 理解触发器的创建和使用方法
7. 能够根据业务需求设计合适的约束策略

## 实践目标

通过本实践，你将学会：
- ✅ 创建和管理主键约束
- ✅ 创建和管理外键约束（包括级联操作）
- ✅ 创建和管理唯一约束
- ✅ 创建和管理检查约束
- ✅ 删除各种约束
- ✅ 创建和管理触发器

## 实践环境

**数据表结构：**

**stu表（学生表）：**
- `id`：学号，CHAR(4)
- `name`：姓名，CHAR(8)
- `sex`：性别，CHAR(2)
- `date`：出生日期，DATE

**sc表（选课表）：**
- `id`：学号，CHAR(4)
- `number`：课号，CHAR(4)
- `grade`：成绩，DECIMAL(5,2)

**course表（课程表）：**
- `number`：课号，CHAR(4)
- `name`：课名，CHAR(20)
- `credit`：学分，INT

## 实践步骤

### 一、约束管理

#### 1. 创建外键约束

在 `sc` 表中设置外键 `fk_sno` 参照 `stu` 表中的学号列。

```sql
ALTER TABLE sc 
ADD CONSTRAINT fk_sno 
FOREIGN KEY (id) REFERENCES stu(id);
```

#### 2. 创建检查约束

在 `sc` 表中对成绩进行约束：0 <= 成绩 <= 100。

**注意：** MySQL 5.7及之前版本不支持CHECK约束，MySQL 8.0.16+才支持。如果版本不支持，可以使用触发器实现。

```sql
-- MySQL 8.0.16+
ALTER TABLE sc 
ADD CONSTRAINT ck_grade 
CHECK (grade >= 0 AND grade <= 100);

-- MySQL 5.7及之前版本，使用触发器实现
DELIMITER $$
CREATE TRIGGER check_grade_before_insert
BEFORE INSERT ON sc
FOR EACH ROW
BEGIN
    IF NEW.grade < 0 OR NEW.grade > 100 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '成绩必须在0-100之间';
    END IF;
END$$

CREATE TRIGGER check_grade_before_update
BEFORE UPDATE ON sc
FOR EACH ROW
BEGIN
    IF NEW.grade < 0 OR NEW.grade > 100 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '成绩必须在0-100之间';
    END IF;
END$$
DELIMITER ;
```

#### 3. 创建唯一约束

在 `course` 表的课名列上建立唯一约束，约束名为 `uq_cname`。

```sql
ALTER TABLE course 
ADD CONSTRAINT uq_cname 
UNIQUE (name);
```

#### 4. 创建主键约束

在 `course` 表的课号列建立主键约束。

```sql
ALTER TABLE course 
ADD CONSTRAINT pk_course 
PRIMARY KEY (number);
```

#### 5. 创建外键约束（级联更新）

在 `sc` 表的课号列建立外键约束 `fk_cno`，参照 `course` 表的课号列的取值，要求实现级联更新。

```sql
ALTER TABLE sc
ADD CONSTRAINT fk_cno 
FOREIGN KEY (number) REFERENCES course(number)
ON UPDATE CASCADE;
```

**级联操作说明：**
- `ON UPDATE CASCADE`：主表更新时，从表自动更新
- `ON DELETE CASCADE`：主表删除时，从表自动删除
- `ON UPDATE SET NULL`：主表更新时，从表设置为NULL
- `ON DELETE SET NULL`：主表删除时，从表设置为NULL

#### 6. 创建唯一约束

在 `stu` 表的姓名列建立唯一约束，约束名为 `uq_sname`。

```sql
ALTER TABLE stu 
ADD CONSTRAINT uq_sname 
UNIQUE (name);
```

#### 7. 创建检查约束

在 `course` 表的学分列建立检查约束 `ck_xf`，检查条件为学分 > 0。

```sql
-- MySQL 8.0.16+
ALTER TABLE course 
ADD CONSTRAINT ck_xf 
CHECK (credit > 0);

-- MySQL 5.7及之前版本，使用触发器实现
DELIMITER $$
CREATE TRIGGER check_credit_before_insert
BEFORE INSERT ON course
FOR EACH ROW
BEGIN
    IF NEW.credit <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '学分必须大于0';
    END IF;
END$$

CREATE TRIGGER check_credit_before_update
BEFORE UPDATE ON course
FOR EACH ROW
BEGIN
    IF NEW.credit <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '学分必须大于0';
    END IF;
END$$
DELIMITER ;
```

### 二、删除约束

#### 8. 删除外键约束

删除 `sc` 表的外键约束 `fk_cno`、`fk_sno`。

```sql
ALTER TABLE sc DROP FOREIGN KEY fk_cno;
ALTER TABLE sc DROP FOREIGN KEY fk_sno;
```

#### 9. 删除主键约束

删除 `stu` 表的主键约束。

```sql
ALTER TABLE stu DROP PRIMARY KEY;
```

#### 10. 删除唯一约束

删除 `course` 表的唯一约束 `uq_cname`。

```sql
ALTER TABLE course DROP INDEX uq_cname;
```

### 三、触发器管理

#### 11. 创建INSERT触发器

创建测试表 `test`，包含一个字段 `date_time`，字段类型 `VARCHAR(50)`。创建触发器 `test_trig`，实现在 `stu` 表中每插入一条学生记录后，则自动在 `test` 表中追加一条插入成功时的日期时间。`NOW()` 函数用来获取当前的日期和时间。为 `stu` 表插入一条记录引发触发器，查看 `test` 表的内容。

```sql
-- 创建测试表
CREATE TABLE test(
    date_time VARCHAR(50)
);

-- 创建触发器
DELIMITER $$
CREATE TRIGGER test_trig
AFTER INSERT ON stu
FOR EACH ROW
BEGIN
    INSERT INTO test VALUES (NOW());
END$$
DELIMITER ;

-- 插入数据触发触发器
INSERT INTO stu VALUES('1', 'Marx', 'F', '1995-10-13');

-- 查看触发器执行结果
SELECT * FROM test;
```

#### 12. 创建DELETE触发器

在 `course` 表上创建触发器 `del_trig`，当 `course` 表上删除一门课程时，级联删除 `sc` 表该课程的记录。删除 `course` 表的一条记录，查看 `sc` 表相应记录是否被自动删除。

```sql
-- 创建触发器
DELIMITER $$
CREATE TRIGGER del_trig
AFTER DELETE ON course
FOR EACH ROW
BEGIN
    DELETE FROM sc WHERE number = OLD.number;
END$$
DELIMITER ;

-- 删除课程记录，触发触发器
DELETE FROM course WHERE number = '1';

-- 查看sc表，验证级联删除
SELECT * FROM sc;
```

## 实践总结

### 关键知识点

#### 约束类型

1. **主键约束（PRIMARY KEY）**
   - 唯一标识表中的每一行
   - 不能为NULL
   - 每个表只能有一个主键

2. **外键约束（FOREIGN KEY）**
   - 保证参照完整性
   - 可以设置级联操作
   - 被参照的表必须先存在

3. **唯一约束（UNIQUE）**
   - 保证列值唯一
   - 允许NULL值
   - 可以有多个唯一约束

4. **检查约束（CHECK）**
   - MySQL 8.0.16+ 支持
   - 限制列值的范围
   - 低版本可用触发器实现

#### 触发器类型

1. **INSERT触发器**
   - `BEFORE INSERT`：插入前触发
   - `AFTER INSERT`：插入后触发
   - 使用 `NEW` 访问新插入的数据

2. **UPDATE触发器**
   - `BEFORE UPDATE`：更新前触发
   - `AFTER UPDATE`：更新后触发
   - 使用 `OLD` 访问旧数据，`NEW` 访问新数据

3. **DELETE触发器**
   - `BEFORE DELETE`：删除前触发
   - `AFTER DELETE`：删除后触发
   - 使用 `OLD` 访问被删除的数据

### 注意事项

- ⚠️ 删除约束前，确保没有数据违反约束
- ⚠️ 外键约束会影响插入和删除性能
- ⚠️ 触发器会增加数据库负担，谨慎使用
- ⚠️ MySQL版本差异：CHECK约束在8.0.16+才支持
- ✅ 约束可以保证数据完整性
- ✅ 触发器可以实现复杂的业务逻辑
- ✅ 级联操作可以简化数据维护

### 最佳实践

1. **约束设计**
   - 合理使用主键和外键
   - 避免过度使用约束
   - 考虑性能影响

2. **触发器使用**
   - 触发器逻辑要简单
   - 避免触发器嵌套
   - 注意触发器性能

---

## 练习题

1. 为 `stu` 表添加主键约束
2. 创建外键约束，实现 `sc` 表与 `course` 表的关联，并设置级联删除
3. 创建触发器，在更新 `sc` 表成绩时，自动记录更新日志
4. 删除所有创建的约束和触发器

---

**上一章：** [索引和视图](/tutorials/java-backend/mysql/第04章-实践篇/03-索引和视图/)

**下一章：** [存储过程和存储函数](/tutorials/java-backend/mysql/第04章-实践篇/05-存储过程和存储函数/) →
