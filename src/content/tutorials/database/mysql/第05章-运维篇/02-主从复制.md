---
title: 主从复制
prevChapter: "java-backend/mysql/第05章-运维篇/01-日志管理"
nextChapter: "java-backend/mysql/第05章-运维篇/03-分库分表"
parentChapter: "java-backend/mysql/README"
---
# 主从复制

> 主从复制是MySQL实现高可用、读写分离和负载均衡的基础。本章学习MySQL主从复制的原理、搭建方法和测试验证。

## ⚡ 快速参考

- **复制原理**：主库binlog → 从库relay log → 从库重放SQL
- **复制优势**：高可用性、读写分离、数据备份、负载均衡
- **复制类型**：异步复制、半同步复制、组复制
- **配置步骤**：主库开启binlog、从库配置server-id、建立复制关系
- **复制命令**：CHANGE MASTER TO、START SLAVE、SHOW SLAVE STATUS
- **故障处理**：查看复制状态、处理复制延迟、处理复制错误
- **应用场景**：高可用架构、读写分离、数据备份、数据分析

## 📚 学习目标

1. 理解主从复制的原理和工作机制
2. 掌握主从复制的配置步骤和方法
3. 理解binlog和relay log的作用
4. 掌握主从复制状态的查看和监控
5. 理解复制延迟的原因和处理方法
6. 掌握主从复制的故障排查和恢复
7. 理解主从复制在高可用架构中的应用
8. 能够搭建和维护MySQL主从复制环境

## 一、主从复制概述

### 1.1 什么是主从复制？

主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。

MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112202655009.png" alt="image-20260112202655009" style="zoom:50%;" />

### 1.2 MySQL 复制的优点

MySQL 复制的优点主要包含以下三个方面：

1. **高可用性**：主库出现问题，可以快速切换到从库提供服务
2. **读写分离**：实现读写分离，降低主库的访问压力
3. **数据备份**：可以在从库中执行备份，以避免备份期间影响主库服务

### 1.3 应用场景

- 🏪 **电商系统**：主库处理写操作，从库处理读操作
- 💰 **金融系统**：主从复制保证数据冗余和可用性
- 📊 **数据分析**：从库进行数据分析，不影响主库性能
- 🔄 **负载均衡**：多个从库分担读请求压力

## 二、主从复制原理

### 2.1 复制原理

MySQL主从复制的核心就是 **二进制日志**，具体的过程如下：

![image-20260112202706419](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112202706419.png)

**复制分成三步：**

1. **Master 主库**：在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中
2. **Slave 从库**：读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log
3. **Slave 从库**：重做中继日志中的事件，将改变反映到它自己的数据

**流程图：**
```
主库(Master)                   从库(Slave)
    |                              |
    | 1. 事务提交                    |
    |--> 写入Binlog                 |
    |                              |
    |                              | 2. IO Thread
    |<-- 读取Binlog ----------------|
    |                              |
    |                              |--> 写入Relay Log
    |                              |
    |                              | 3. SQL Thread
    |                              |--> 重做Relay Log
    |                              |--> 更新数据
```

### 2.2 关键组件

- **Binlog（二进制日志）**：主库记录所有变更操作
- **Relay Log（中继日志）**：从库临时存储主库的binlog
- **IO Thread**：从库读取主库binlog的线程
- **SQL Thread**：从库执行relay log的线程

## 三、主从复制搭建

### 3.1 环境准备

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112202724119.png" alt="image-20260112202724119" style="zoom:50%;" />

准备好两台服务器之后，在上述的两台服务器中分别安装好MySQL，并完成基础的初始化准备(安装、密码配置等操作)工作。

**服务器规划：**
- `192.168.200.200` 作为主服务器master
- `192.168.200.201` 作为从服务器slave

**准备工作：**
1. 确保两台服务器MySQL版本兼容（建议相同版本）
2. 确保网络互通
3. 关闭防火墙或开放3306端口
4. 确保MySQL服务正常运行

### 3.2 主库配置

#### 3.2.1 修改配置文件

修改主库配置文件 `/etc/my.cnf`：

```ini
# /etc/my.cnf
[mysqld]
# mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1
server-id=1

# 是否只读,1 代表只读, 0 代表读写
read-only=0

# 忽略的数据, 指不需要同步的数据库
# binlog-ignore-db=mysql

# 指定同步的数据库（不配置则同步所有数据库）
# binlog-do-db=db01
```

#### 3.2.2 重启MySQL服务器

```bash
systemctl restart mysqld
```

#### 3.2.3 创建远程连接账号

登录mysql，创建远程连接的账号，并授予主从复制权限：

```sql
-- 创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务
CREATE USER 'itcast'@'%' IDENTIFIED WITH mysql_native_password BY 'Root@123456';

-- 为 'itcast'@'%' 用户分配主从复制权限
GRANT REPLICATION SLAVE ON *.* TO 'itcast'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

#### 3.2.4 查看二进制日志坐标

通过指令，查看二进制日志坐标：

```sql
SHOW MASTER STATUS;
```

![image-20260112202741134](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112202741134.png)

**输出示例：**

```
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| binlog.000004    |      663 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
```

**字段含义说明：**
- `File`：从哪个日志文件开始推送日志文件
- `Position`：从哪个位置开始推送日志
- `Binlog_Do_DB`：指定同步的数据库
- `Binlog_Ignore_DB`：指定不需要同步的数据库

**重要提示：** 记录下 `File` 和 `Position` 的值，后续在从库配置中会用到。

### 3.3 从库配置

#### 3.3.1 修改配置文件

修改从库配置文件 `/etc/my.cnf`：

```ini
# /etc/my.cnf
[mysqld]
# mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可
server-id=2

# 是否只读,1 代表只读, 0 代表读写
read-only=1
```

#### 3.3.2 重新启动MySQL服务

```bash
systemctl restart mysqld
```

#### 3.3.3 设置主库配置

登录mysql，设置主库配置。

**MySQL 8.0.23 及之后版本的语法：**
```sql
CHANGE REPLICATION SOURCE TO 
    SOURCE_HOST='192.168.200.200',
    SOURCE_USER='itcast',
    SOURCE_PASSWORD='Root@123456',
    SOURCE_LOG_FILE='binlog.000004',
    SOURCE_LOG_POS=663;
```

**MySQL 8.0.23 之前版本的语法：**
```sql
CHANGE MASTER TO 
    MASTER_HOST='192.168.200.200',
    MASTER_USER='itcast',
    MASTER_PASSWORD='Root@123456',
    MASTER_LOG_FILE='binlog.000004',
    MASTER_LOG_POS=663;
```

**参数对应关系：**

| 参数名（8.0.23+） | 参数名（8.0.23之前） | 含义 |
|------------------|---------------------|------|
| SOURCE_HOST | MASTER_HOST | 主库IP地址 |
| SOURCE_USER | MASTER_USER | 连接主库的用户名 |
| SOURCE_PASSWORD | MASTER_PASSWORD | 连接主库的密码 |
| SOURCE_LOG_FILE | MASTER_LOG_FILE | binlog日志文件名 |
| SOURCE_LOG_POS | MASTER_LOG_POS | binlog日志文件位置 |

#### 3.3.4 开启同步操作

```sql
-- MySQL 8.0.22之后
START REPLICA;

-- MySQL 8.0.22之前
START SLAVE;
```

#### 3.3.5 查看主从同步状态

```sql
-- MySQL 8.0.22之后
SHOW REPLICA STATUS \G;

-- MySQL 8.0.22之前
SHOW SLAVE STATUS \G;
```

![image-20260112202814109](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112202814109.png)

**关键字段说明：**

- `Slave_IO_Running: Yes`：IO线程运行正常
- `Slave_SQL_Running: Yes`：SQL线程运行正常
- `Seconds_Behind_Master: 0`：从库延迟秒数（0表示无延迟）
- `Last_IO_Error`：最后的IO错误（为空表示无错误）
- `Last_SQL_Error`：最后的SQL错误（为空表示无错误）

## 四、主从复制测试

### 4.1 测试步骤

#### 1. 在主库上创建数据库、表，并插入数据

```sql
-- 在主库执行
CREATE DATABASE db01;
USE db01;

CREATE TABLE tb_user(
    id INT(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    sex VARCHAR(1)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;

INSERT INTO tb_user(id, name, sex) VALUES
    (NULL, 'Tom', '1'),
    (NULL, 'Trigger', '0'),
    (NULL, 'Dawn', '1');
```

#### 2. 在从库中查询数据，验证主从是否同步

```sql
-- 在从库执行
USE db01;
SELECT * FROM tb_user;
```

**预期结果：** 从库应该能查询到主库插入的三条数据。

### 4.2 验证主从同步状态

在主库执行操作后，可以在从库实时查看同步状态：

```sql
-- 在从库查看同步状态
SHOW REPLICA STATUS \G;

-- 查看延迟情况
SELECT 
    NOW() AS current_time,
    TIMEDIFF(NOW(), 
        (SELECT MAX(create_time) FROM db01.tb_user)
    ) AS replication_delay;
```

### 4.3 常见问题排查

#### 问题1：Slave_IO_Running 为 No

**可能原因：**
- 网络连接问题
- 主库账号权限不足
- 主库binlog文件不存在

**解决方法：**
```sql
-- 检查从库配置
SHOW REPLICA STATUS \G;

-- 重新配置主库信息
STOP REPLICA;
CHANGE REPLICATION SOURCE TO ...;
START REPLICA;
```

#### 问题2：Slave_SQL_Running 为 No

**可能原因：**
- SQL执行错误
- 从库数据不一致

**解决方法：**
```sql
-- 查看具体错误
SHOW REPLICA STATUS \G;

-- 跳过错误（谨慎使用）
SET GLOBAL sql_slave_skip_counter = 1;
START REPLICA;
```

#### 问题3：主从延迟较大

**可能原因：**
- 从库性能不足
- 网络延迟
- 主库写入压力过大

**解决方法：**
- 优化从库硬件配置
- 检查网络状况
- 考虑使用并行复制

## 五、主从复制管理

### 5.1 停止主从复制

```sql
-- MySQL 8.0.22之后
STOP REPLICA;

-- MySQL 8.0.22之前
STOP SLAVE;
```

### 5.2 重置主从复制

```sql
-- 在从库执行
STOP REPLICA;
RESET REPLICA ALL;  -- 8.0.22之后
-- RESET SLAVE ALL;  -- 8.0.22之前

-- 重新配置
CHANGE REPLICATION SOURCE TO ...;
START REPLICA;
```

### 5.3 查看主从复制信息

```sql
-- 查看从库状态
SHOW REPLICA STATUS \G;

-- 查看主库状态
SHOW MASTER STATUS;

-- 查看所有从库连接
SHOW PROCESSLIST;
```

## 六、本章总结

### 核心要点

1. **主从复制原理**：基于binlog的异步复制
2. **关键组件**：Binlog、Relay Log、IO Thread、SQL Thread
3. **配置要点**：server-id唯一、read-only设置、用户权限
4. **状态监控**：Slave_IO_Running、Slave_SQL_Running

### 最佳实践

1. ✅ **server-id必须唯一**：整个复制环境中不能重复
2. ✅ **从库设为只读**：防止误操作导致数据不一致
3. ✅ **监控主从状态**：定期检查复制延迟和错误
4. ✅ **备份从库数据**：从库可以安全备份，不影响主库
5. ⚠️ **网络稳定性**：确保主从之间网络连接稳定

### 应用场景

| 场景 | 说明 |
|------|------|
| **读写分离** | 主库写，从库读，提升性能 |
| **高可用** | 主库故障时可切换从库 |
| **数据备份** | 从库执行备份不影响主库 |
| **数据分析** | 从库进行数据分析 |
| **负载均衡** | 多个从库分担读请求 |

---

## 练习题

```sql
-- 1. 在主库创建测试数据
CREATE DATABASE test_replication;
USE test_replication;
CREATE TABLE test_table(id INT PRIMARY KEY, name VARCHAR(50));
INSERT INTO test_table VALUES(1, 'test1');

-- 2. 在从库验证数据同步
USE test_replication;
SELECT * FROM test_table;

-- 3. 查看主从复制状态
SHOW REPLICA STATUS \G;

-- 4. 查看主库binlog状态
SHOW MASTER STATUS;
```

---

**上一章：** [日志管理](/tutorials/java-backend/mysql/第05章-运维篇/01-日志管理/)

**下一章：** [分库分表](/tutorials/java-backend/mysql/第05章-运维篇/03-分库分表/) →
