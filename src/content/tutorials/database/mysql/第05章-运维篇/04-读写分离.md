---
title: 读写分离
prevChapter: "java-backend/mysql/第05章-运维篇/03-分库分表"
parentChapter: "java-backend/mysql/README"
---
# 读写分离

> 读写分离是提升数据库性能的重要手段，通过将读操作和写操作分发到不同的数据库服务器，可以显著提升系统的并发处理能力。本章学习MySQL读写分离的实现方式。

## ⚡ 快速参考

- **读写分离原理**：主库处理写操作，从库处理读操作，通过主从复制保持数据同步
- **实现方式**：应用层实现、中间件实现（MyCat、ShardingSphere）
- **优势**：提升性能、降低延迟、高可用性、负载均衡
- **配置要点**：主从复制配置、读写分离规则、负载均衡策略
- **应用场景**：高并发读操作、电商系统、内容管理系统
- **注意事项**：主从延迟、数据一致性、故障切换
- **中间件**：MyCat、ShardingSphere、ProxySQL

## 📚 学习目标

1. 理解读写分离的原理和优势
2. 掌握基于主从复制的读写分离实现
3. 理解应用层和中间件两种实现方式
4. 掌握MyCat实现读写分离的配置方法
5. 理解读写分离中的主从延迟问题
6. 掌握读写分离的负载均衡策略
7. 理解读写分离在高并发场景中的应用
8. 能够搭建和维护MySQL读写分离架构

## 一、读写分离概述

### 1.1 什么是读写分离？

读写分离，简单地说是把对数据库的读和写操作分开，以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。

**架构示意图：**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212522433.png" alt="image-20260112212522433" style="zoom:50%;" />

### 1.2 读写分离的优势

通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。

**优势：**
- ✅ **提升性能**：主库专注写操作，从库专注读操作
- ✅ **降低延迟**：减少主库压力，提升响应速度
- ✅ **高可用性**：主库故障时，可以切换到从库
- ✅ **负载均衡**：多个从库分担读请求压力

### 1.3 应用场景

- 🏪 **电商系统**：高并发读操作（商品浏览、搜索）
- 💰 **金融系统**：读写分离保证数据安全和性能
- 📊 **内容管理系统**：大量内容查询操作
- 🎮 **游戏系统**：玩家数据查询频繁

## 二、一主一从

### 2.1 原理

MySQL的主从复制，是基于二进制日志（binlog）实现的。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212543468.png" alt="image-20260112212543468" style="zoom: 50%;" />

**主从复制过程：**
1. 主库执行写操作，记录到binlog
2. 从库IO线程读取主库binlog
3. 从库SQL线程执行binlog中的SQL
4. 从库数据与主库保持一致

详细的主从复制配置请参考：[02-主从复制](02-主从复制.md)

### 2.2 环境准备

**主机角色分配：**

| 主机 | 角色 | 用户名 | 密码 |
|------|------|--------|------|
| 192.168.200.211 | master | root | 1234 |
| 192.168.200.212 | slave | root | 1234 |

**备注：** 主从复制的搭建，可以参考前面课程中主从复制章节讲解的步骤操作。

## 三、一主一从读写分离

MyCat控制后台数据库的读写分离和负载均衡由 `schema.xml` 文件 `datahost` 标签的 `balance` 属性控制。

### 3.1 schema.xml配置

**配置示例：**
```xml
<!-- 配置逻辑库 -->
<schema name="ITCAST_RW" checkSQLschema="true" sqlMaxLimit="100" dataNode="dn7">
</schema>

<dataNode name="dn7" dataHost="dhost7" database="itcast" />

<dataHost name="dhost7" maxCon="1000" minCon="10" balance="1" writeType="0"
          dbType="mysql" dbDriver="jdbc" switchType="1" slaveThreshold="100">
    <heartbeat>select user()</heartbeat>
    <writeHost host="master1" 
               url="jdbc:mysql://192.168.200.211:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
               user="root" password="1234">
        <readHost host="slave1" 
                  url="jdbc:mysql://192.168.200.212:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
                  user="root" password="1234" />
    </writeHost>
</dataHost>
```

**配置说明：**
- `writeHost`：代表写操作对应的数据库（主库）
- `readHost`：代表读操作对应的数据库（从库）
- ![image-20260112212633894](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212633894.png)

writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。所以我们要想实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。

而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个非常重要的负责均衡的参数balance，取值有4种，具体含义如下：

### 3.2 balance参数说明

`balance` 参数控制读写分离和负载均衡策略，取值有4种：

| 参数值 | 含义 |
|--------|------|
| **0** | 不开启读写分离机制，所有读操作都发送到当前可用的writeHost上 |
| **1** | 全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对双主双从模式） |
| **2** | 所有的读写操作都随机在writeHost、readHost上分发 |
| **3** | 所有的读请求随机分发到writeHost对应的readHost上执行，writeHost不负担读压力 |

**在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。**

### 3.3 server.xml配置

配置root用户可以访问SHOPPING、ITCAST以及ITCAST_RW逻辑库。

```xml
<user name="root" defaultAccount="true">
    <property name="password">123456</property>
    <property name="schemas">SHOPPING,ITCAST,ITCAST_RW</property>
</user>
```

### 3.4 测试

配置完毕MyCat后，重新启动MyCat：

```bash
bin/mycat stop
bin/mycat start
```

然后观察，在执行增删改操作时，对应的主库及从库的数据变化。在执行查询操作时，检查主库及从库对应的数据变化。

**测试步骤：**
1. 在MyCat中执行写操作（INSERT、UPDATE、DELETE）
2. 在主库和从库中查看数据变化
3. 在MyCat中执行读操作（SELECT）
4. 查看SQL路由情况（通过MyCat管理端口）

**注意事项：**
在测试中，我们可以发现当主节点Master宕机之后，业务系统就只能够读，而不能写入数据了。

![image-20260112212731545](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212731545.png)

那如何解决这个问题呢？这个时候我们就得通过另外一种主从复制结构来解决了，也就是我们接下来讲解的**双主双从**。

## 四、双主双从

### 4.1 架构介绍

一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212738317.png" alt="image-20260112212738317" style="zoom:50%;" />

**架构图：**
```
               应用层
                  |
                  |
              MyCat
         /      |      \
        |       |       |
   Master1   Master2    |
    (写)     (备用)     |
      |         |       |
   Slave1    Slave2    |
    (读)      (读)     |
```

### 4.2 环境准备

我们需要准备5台服务器，具体的服务器及软件安装情况如下：

| 编号 | IP | 预装软件 | 角色 |
|------|-----|---------|------|
| 1 | 192.168.200.210 | MyCat、MySQL | MyCat中间件服务器 |
| 2 | 192.168.200.211 | MySQL | M1（主库1） |
| 3 | 192.168.200.212 | MySQL | S1（从库1） |
| 4 | 192.168.200.213 | MySQL | M2（主库2） |
| 5 | 192.168.200.214 | MySQL | S2（从库2） |

**关闭防火墙：**
```bash
systemctl stop firewalld
systemctl disable firewalld
```

### 4.3 搭建步骤

#### 4.3.1 主库配置

**1). Master1(192.168.200.211) 配置**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212756641.png" alt="image-20260112212756641" style="zoom:50%;" />

修改配置文件 `/etc/my.cnf`：
```ini
[mysqld]
# mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1
server-id=1
# 指定同步的数据库
binlog-do-db=db01
binlog-do-db=db02
binlog-do-db=db03
# 在作为从数据库的时候，有写入操作也要更新二进制日志文件
log-slave-updates
```

重启MySQL服务器：
```bash
systemctl restart mysqld
```

创建账户并授权：
```sql
CREATE USER 'itcast'@'%' IDENTIFIED WITH mysql_native_password BY 'Root@123456';
GRANT REPLICATION SLAVE ON *.* TO 'itcast'@'%';
```

查看二进制日志坐标：
```sql
SHOW MASTER STATUS;
```

![image-20260112212815553](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212815553.png)

**2). Master2(192.168.200.213) 配置**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212829281.png" alt="image-20260112212829281" style="zoom:50%;" />

修改配置文件 `/etc/my.cnf`：
```ini
[mysqld]
# mysql 服务ID，保证整个集群环境中唯一
server-id=3
# 指定同步的数据库
binlog-do-db=db01
binlog-do-db=db02
binlog-do-db=db03
# 在作为从数据库的时候，有写入操作也要更新二进制日志文件
log-slave-updates
```

重启MySQL服务器并创建账户（同Master1）。

#### 4.3.2 从库配置

**1). Slave1(192.168.200.212) 配置**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212914753.png" alt="image-20260112212914753" style="zoom:50%;" />

修改配置文件 `/etc/my.cnf`：
```ini
[mysqld]
server-id=2
```

**2). Slave2(192.168.200.214) 配置**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112214318748.png" alt="image-20260112214318748" style="zoom:50%;" />

修改配置文件 `/etc/my.cnf`：
```ini
[mysqld]
server-id=4
```

重启MySQL服务器。

#### 4.3.3 从库关联主库

**1). 两台从库配置关联的主库**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112214338322.png" alt="image-20260112214338322" style="zoom:50%;" />

需要注意slave1对应的是master1，slave2对应的是master2。

在 slave1(192.168.200.212) 上执行：
```sql
CHANGE MASTER TO 
    MASTER_HOST='192.168.200.211', 
    MASTER_USER='itcast',
    MASTER_PASSWORD='Root@123456', 
    MASTER_LOG_FILE='binlog.000002',
    MASTER_LOG_POS=663;
```

在 slave2(192.168.200.214) 上执行：
```sql
CHANGE MASTER TO 
    MASTER_HOST='192.168.200.213', 
    MASTER_USER='itcast',
    MASTER_PASSWORD='Root@123456', 
    MASTER_LOG_FILE='binlog.000002',
    MASTER_LOG_POS=663;
```

启动两台从库主从复制：
```sql
START SLAVE;
SHOW SLAVE STATUS \G;
```

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112214354098.png" alt="image-20260112214354098" style="zoom:50%;" />

**2). 两台主库相互复制**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112214404655.png" alt="image-20260112214404655" style="zoom:50%;" />

Master2 复制 Master1，Master1 复制 Master2。

在 Master1(192.168.200.211) 上执行：
```sql
CHANGE MASTER TO 
    MASTER_HOST='192.168.200.213', 
    MASTER_USER='itcast',
    MASTER_PASSWORD='Root@123456', 
    MASTER_LOG_FILE='binlog.000002',
    MASTER_LOG_POS=663;
```

在 Master2(192.168.200.213) 上执行：
```sql
CHANGE MASTER TO 
    MASTER_HOST='192.168.200.211', 
    MASTER_USER='itcast',
    MASTER_PASSWORD='Root@123456', 
    MASTER_LOG_FILE='binlog.000002',
    MASTER_LOG_POS=663;
```

启动两台主库的主从复制：
```sql
START SLAVE;
SHOW SLAVE STATUS \G;
```

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112214615981.png" alt="image-20260112214615981" style="zoom:50%;" />

### 4.4 测试验证

分别在两台主库Master1、Master2上执行DDL、DML语句，查看涉及到的数据库服务器的数据同步情况。

**在Master1中执行：**
```sql
CREATE DATABASE db01;
USE db01;
CREATE TABLE tb_user(
    id INT(11) NOT NULL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    sex VARCHAR(1)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;

INSERT INTO tb_user(id, name, sex) VALUES
    (1, 'Tom', '1'),
    (2, 'Trigger', '0'),
    (3, 'Dawn', '1');
```

**验证：** 数据应该同步到Master2、Slave1和Slave2。

**在Master2中执行：**
```sql
INSERT INTO tb_user(id, name, sex) VALUES
    (4, 'Jack Ma', '1'),
    (5, 'Coco', '0'),
    (6, 'Jerry', '1');
```

**验证：** 数据应该同步到Master1、Slave1和Slave2。

## 五、双主双从读写分离

### 5.1 schema.xml配置

**配置逻辑库：**
```xml
<schema name="ITCAST_RW2" checkSQLschema="true" sqlMaxLimit="100" dataNode="dn7">
</schema>
```

**配置数据节点：**
```xml
<dataNode name="dn7" dataHost="dhost7" database="db01" />
```

**配置节点主机：**
```xml
<dataHost name="dhost7" maxCon="1000" minCon="10" balance="1" writeType="0"
          dbType="mysql" dbDriver="jdbc" switchType="1" slaveThreshold="100">
    <heartbeat>select user()</heartbeat>
    
    <writeHost host="master1" 
               url="jdbc:mysql://192.168.200.211:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
               user="root" password="1234">
        <readHost host="slave1" 
                  url="jdbc:mysql://192.168.200.212:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
                  user="root" password="1234" />
    </writeHost>
    
    <writeHost host="master2" 
               url="jdbc:mysql://192.168.200.213:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
               user="root" password="1234">
        <readHost host="slave2" 
                  url="jdbc:mysql://192.168.200.214:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
                  user="root" password="1234" />
    </writeHost>
</dataHost>
```

具体的对应情况下：



**属性说明：**

- **balance="1"**：代表全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单地说，当双主双从模式(M1->S1，M2->S2，并且 M1 与 M2 互为主备)，正常情况下，M2、S1、S2 都参与 select 语句的负载均衡

- **writeType**：
  - `0`：写操作都转发到第1台writeHost，writeHost1挂了，会切换到writeHost2上
  - `1`：所有的写操作都随机地发送到配置的writeHost上

- **switchType**：
  - `-1`：不自动切换
  - `1`：自动切换

### 5.2 server.xml配置

配置root用户也可以访问到逻辑库 ITCAST_RW2。

```xml
<user name="root" defaultAccount="true">
    <property name="password">123456</property>
    <property name="schemas">SHOPPING,ITCAST,ITCAST_RW2</property>
</user>
```

### 5.3 测试验证

登录MyCat，测试查询及更新操作，判定是否能够进行读写分离，以及读写分离的策略是否正确。当主库挂掉一个之后，是否能够自动切换。

**测试步骤：**
1. 执行写操作，验证数据写入到主库
2. 执行读操作，验证数据从从库读取
3. 停止Master1，验证自动切换到Master2
4. 恢复Master1，验证自动恢复

## 六、本章总结

### 核心要点

1. **读写分离原理**：主库写，从库读
2. **配置关键**：balance参数控制负载均衡策略
3. **高可用架构**：双主双从实现主库高可用
4. **自动切换**：switchType控制故障自动切换

### 配置对比

| 配置项 | 一主一从 | 双主双从 |
|--------|---------|---------|
| **主库数量** | 1个 | 2个（互为主备） |
| **从库数量** | 1个 | 2个 |
| **高可用性** | 主库故障需手动切换 | 主库故障自动切换 |
| **复杂度** | 简单 | 复杂 |
| **适用场景** | 中小型应用 | 大型应用 |

### 最佳实践

1. ✅ **读写分离**：balance=1或3，根据场景选择
2. ✅ **故障切换**：switchType=1，启用自动切换
3. ✅ **监控告警**：监控主从复制状态
4. ✅ **定期测试**：定期进行故障切换测试

---

## 练习题

```sql
-- 1. 测试读写分离
-- 在MyCat中执行写操作
INSERT INTO test_table VALUES(1, 'test');

-- 在主库和从库验证数据
-- 主库应该能看到数据
-- 从库通过复制也应该能看到数据

-- 2. 测试故障切换
-- 停止主库，验证从库是否可以提供服务
-- 恢复主库，验证数据同步
```

---

**上一章：** [分库分表](/tutorials/java-backend/mysql/第05章-运维篇/03-分库分表/)

**恭喜完成MySQL运维篇学习！** 🎉

**🎉 恭喜你掌握了 MySQL 数据库的完整知识体系！**

