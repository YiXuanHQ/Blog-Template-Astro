---
title: 分库分表
prevChapter: "java-backend/mysql/第05章-运维篇/02-主从复制"
nextChapter: "java-backend/mysql/第05章-运维篇/04-读写分离"
parentChapter: "java-backend/mysql/README"
---
# 分库分表

> 当单数据库无法满足业务需求时，需要对数据库进行分库分表处理。本章学习分库分表的基本概念、拆分策略以及MyCat中间件的使用。

## ⚡ 快速参考

- **拆分策略**：垂直拆分（垂直分库、垂直分表）、水平拆分（水平分库、水平分表）
- **垂直分库**：按业务模块拆分，不同表存储在不同库
- **垂直分表**：按字段拆分，将大表拆分为多个小表
- **水平分库**：按数据量拆分，将数据分散到多个库
- **水平分表**：按数据量拆分，将数据分散到多个表
- **分片规则**：范围分片、哈希分片、取模分片、一致性哈希
- **中间件**：MyCat、ShardingSphere、TDDL
- **问题解决**：跨库查询、分布式事务、主键生成、数据迁移

## 📚 学习目标

1. 理解分库分表的原因和适用场景
2. 掌握垂直拆分和水平拆分的区别和应用
3. 理解各种分片规则的特点和选择
4. 掌握MyCat中间件的配置和使用
5. 理解分库分表带来的问题和解决方案
6. 掌握分布式主键的生成策略
7. 理解跨库查询和分布式事务的处理
8. 能够根据业务需求设计合理的分库分表方案

## 一、分库分表概述

### 1.1 问题分析

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112202850557.png" alt="image-20260112202850557" style="zoom:50%;" />

随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：

**1. IO瓶颈：**
- 热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低
- 请求数据太多，带宽不够，网络IO瓶颈

**2. CPU瓶颈：**
- 排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源
- 请求数太多，CPU出现瓶颈

为了解决上述问题，我们需要对数据库进行分库分表处理。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203022651.png" alt="image-20260112203022651" style="zoom:50%;" />

分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。

### 1.2 拆分策略

分库分表的形式，主要是两种：**垂直拆分**和**水平拆分**。而拆分的粒度，一般又分为**分库**和**分表**，所以组成的拆分策略最终如下：

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203041325.png" alt="image-20260112203041325" style="zoom:50%;" />

```
拆分策略
├── 垂直拆分
│   ├── 垂直分库
│   └── 垂直分表
└── 水平拆分
    ├── 水平分库
    └── 水平分表
```

### 1.3 垂直拆分

#### 1.3.1 垂直分库

垂直分库：以表为依据，根据业务将不同表拆分到不同库中。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203109153.png" alt="image-20260112203109153" style="zoom:50%;" />

**特点：**
- 每个库的表结构都不一样
- 每个库的数据也不一样
- 所有库的并集是全量数据

**示例：**
```
原始数据库
├── 用户表
├── 订单表
└── 商品表

垂直分库后
├── 用户库
│   └── 用户表
├── 订单库
│   └── 订单表
└── 商品库
    └── 商品表
```

#### 1.3.2 垂直分表

垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203428421.png" alt="image-20260112203428421" style="zoom:50%;" />

**特点：**

- 每个表的结构都不一样
- 每个表的数据也不一样，一般通过一列（主键/外键）关联
- 所有表的并集是全量数据

**示例：**
```
原始用户表
├── id
├── name
├── password
├── phone
├── email
├── address
└── detail_info

垂直分表后
├── 用户基本信息表
│   ├── id
│   ├── name
│   ├── password
│   └── phone
└── 用户扩展信息表
    ├── id (关联字段)
    ├── email
    ├── address
    └── detail_info
```

### 1.4 水平拆分

#### 1.4.1 水平分库

水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203443042.png" alt="image-20260112203443042" style="zoom:50%;" />

**特点：**
- 每个库的表结构都一样
- 每个库的数据都不一样
- 所有库的并集是全量数据

**示例：**
```
原始订单库
└── 订单表 (1000万条数据)

水平分库后
├── 订单库1
│   └── 订单表 (330万条)
├── 订单库2
│   └── 订单表 (330万条)
└── 订单库3
    └── 订单表 (340万条)
```

#### 1.4.2 水平分表

水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203452426.png" alt="image-20260112203452426" style="zoom:50%;" />

**特点：**
- 每个表的表结构都一样
- 每个表的数据都不一样
- 所有表的并集是全量数据

**示例：**
```
原始订单表
└── 订单表 (1000万条数据)

水平分表后
├── 订单表_1 (330万条)
├── 订单表_2 (330万条)
└── 订单表_3 (340万条)
```

### 1.5 实现技术

**shardingJDBC：**
- 基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理
- 需要自行编码配置实现，只支持java语言，性能较高

**MyCat：**

- 数据库分库分表中间件，不用调整代码即可实现分库分表
- 支持多种语言，性能不及前者

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203514091.png" alt="image-20260112203514091" style="zoom:50%;" />

**本次课程，我们选择了MyCat数据库中间件，通过MyCat中间件来完成分库分表操作。**

## 二、MyCat概述

### 2.1 什么是MyCat？

Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。

开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。具体的分库分表的策略，只需要在MyCat中配置即可。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203528036.png" alt="image-20260112203528036" style="zoom:50%;" />

**优势：**
- ✅ 性能可靠稳定
- ✅ 强大的技术团队
- ✅ 体系完善
- ✅ 社区活跃

### 2.2 架构组成

**服务器规划：**
- `192.168.200.210`：JDK、Mycat（MyCat中间件服务器）
- `192.168.200.210`：MySQL（分片服务器）
- `192.168.200.213`：MySQL（分片服务器）
- `192.168.200.214`：MySQL（分片服务器）

### 2.3 下载安装

**下载地址：** http://dl.mycat.org.cn/

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203546079.png" alt="image-20260112203546079" style="zoom: 67%;" />

**安装步骤：**

Mycat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，需要在准备好的服务器中安装如下软件：

1. **MySQL**：数据存储
2. **JDK**：Java运行环境
3. **Mycat**：中间件

具体的安装步骤：参考资料中提供的《MyCat安装文档》即可，里面有详细的安装及配置步骤。

### 2.4 目录介绍

MyCat安装后，主要目录结构如下：

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203902476.png" alt="image-20260112203902476" style="zoom:50%;" />

```
mycat/
├── bin/          # 存放可执行文件，用于启动停止mycat
├── conf/         # 存放mycat的配置文件
├── lib/          # 存放mycat的项目依赖包（jar）
└── logs/         # 存放mycat的日志文件
```

### 2.5 概念介绍

在MyCat的整体结构中，分为两个部分：**上面的逻辑结构**、**下面的物理结构**。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203918667.png" alt="image-20260112203918667" style="zoom:50%;" />

**逻辑结构：**

- 逻辑库：对应用层暴露的数据库名称
- 逻辑表：对应用层暴露的表名称
- 分片规则：数据分片的规则
- 分片节点：数据存储的节点

**物理结构：**
- 数据节点：实际的数据库节点
- 数据源：数据库连接信息

在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的。

## 三、MyCat入门

### 3.1 需求场景

由于 `tb_order` 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对 `tb_order` 表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112203946930.png" alt="image-20260112203946930" style="zoom:50%;" />

### 3.2 环境准备

准备3台服务器：
- `192.168.200.210`：MyCat中间件服务器，同时也是第一个分片服务器
- `192.168.200.213`：第二个分片服务器
- `192.168.200.214`：第三个分片服务器

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112204017349.png" alt="image-20260112204017349" style="zoom:50%;" />

并且在上述3台数据库中创建数据库 `db01`。

### 3.3 配置MyCat

#### 3.3.1 schema.xml配置

schema.xml 作为MyCat中最重要的配置文件之一, 涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112204109415.png" alt="image-20260112204109415" style="zoom:50%;" />

在 `schema.xml` 中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。

主要包含以下三组标签：

- schema标签
- datanode标签
- datahost标签

**完整配置：**

```xml
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">
    <schema name="DB01" checkSQLschema="true" sqlMaxLimit="100">
        <table name="TB_ORDER" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
    </schema>
    
    <dataNode name="dn1" dataHost="dhost1" database="db01" />
    <dataNode name="dn2" dataHost="dhost2" database="db01" />
    <dataNode name="dn3" dataHost="dhost3" database="db01" />
    
    <dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"
              writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"
              slaveThreshold="100">
        <heartbeat>select user()</heartbeat>
        <writeHost host="master" 
                   url="jdbc:mysql://192.168.200.210:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
                   user="root" password="1234" />
    </dataHost>
    
    <dataHost name="dhost2" maxCon="1000" minCon="10" balance="0"
              writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"
              slaveThreshold="100">
        <heartbeat>select user()</heartbeat>
        <writeHost host="master" 
                   url="jdbc:mysql://192.168.200.213:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
                   user="root" password="1234" />
    </dataHost>
    
    <dataHost name="dhost3" maxCon="1000" minCon="10" balance="0"
              writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"
              slaveThreshold="100">
        <heartbeat>select user()</heartbeat>
        <writeHost host="master" 
                   url="jdbc:mysql://192.168.200.214:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
                   user="root" password="1234" />
    </dataHost>
</mycat:schema>
```

上面的示例只是一个完整的参考配置，`schema.xml` 作为 MyCat 中最重要的配置文件之一，涵盖了 **逻辑库、逻辑表、分片规则、分片节点及数据源** 的配置。其核心由以下三组标签组成：

- `schema` 标签
- `dataNode` 标签
- `dataHost` 标签

下面对这些标签做更细致的说明，方便查阅和记忆。

##### 1）`schema` 标签 —— 定义逻辑库

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112205616279.png" alt="image-20260112205616279" style="zoom:50%;" />

`schema` 标签用于定义 MyCat 实例中的**逻辑库**，一个 MyCat 实例中可以有多个逻辑库，可以通过多个 `schema` 标签来划分不同的逻辑库。

在 MyCat 中：

- **逻辑库（schema） ≈ MySQL 中的 database 概念**
- 需要操作某个逻辑库下的表时，同样需要先执行 `USE xxx` 来切换逻辑库

**核心属性：**

- **`name`**：指定自定义的逻辑库库名  
- **`checkSQLschema`**：在 SQL 语句中如果指定了数据库名称，执行时是否自动去除  
  - `true`：自动去除  
  - `false`：不自动去除  
- **`sqlMaxLimit`**：在未显式指定 `LIMIT` 的情况下，列表查询最多返回多少条记录

##### 2）`schema` 中的 `table` —— 定义逻辑表

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112205645290.png" alt="image-20260112205645290" style="zoom:50%;" />

`table` 标签定义了 MyCat 中某个逻辑库（`schema`）下的**逻辑表**，**所有需要拆分的表都需要在 `table` 标签中定义**。

**核心属性：**

- **`name`**：定义逻辑表名，在该逻辑库下唯一
- **`dataNode`**：定义逻辑表所属的 `dataNode`，需要与下面 `dataNode` 标签中的 `name` 对应；多个节点用英文逗号分隔
- **`rule`**：分片规则的名字，对应在 `rule.xml` 中定义的分片规则
- **`primaryKey`**：逻辑表对应真实物理表的主键字段名
- **`type`**：逻辑表类型  
  - 不配置时：默认是**普通表**  
  - 配置为 `global`：表示**全局表**（每个分片库都会有一份完整数据）

#### 3.3.2 datanode标签

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112205700810.png" alt="image-20260112205700810" style="zoom:50%;" />

`dataNode` 标签用于定义 **数据节点**，是连接逻辑结构与物理库的桥梁。

**核心属性：**

- **`name`**：数据节点名称，在 `schema.xml` 中唯一  
- **`dataHost`**：数据库实例主机名称，对应下方 `dataHost` 标签中的 `name` 属性  
- **`database`**：定义该分片所属的物理数据库名称（即某个 MySQL 实例中的 database）

在示例中：

- `dn1` 对应 `dhost1` 上的 `db01`
- `dn2` 对应 `dhost2` 上的 `db01`
- `dn3` 对应 `dhost3` 上的 `db01`

#### 3.3.3 datahost标签

![image-20260112205710713](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112205710713.png)

`dataHost` 标签在 MyCat 逻辑结构中属于**底层标签**，用来定义：

- 具体的数据库实例信息
- 读写分离策略
- 心跳检测语句等

**核心属性：**

- **`name`**：唯一标识，供 `dataNode` 的 `dataHost` 属性引用  
- **`maxCon` / `minCon`**：最大连接数 / 最小连接数  
- **`balance`**：负载均衡策略，常见取值 `0、1、2、3`  
- **`writeType`**：写操作的分发方式  
  - `0`：写操作只发往第一个 `writeHost`，第一个挂了才切到第二个  
  - `1`：写操作在配置的多个 `writeHost` 之间随机分发  
- **`dbDriver`**：数据库驱动类型，支持 `native`、`jdbc` 等  

标签体内部通常包含：

- `<heartbeat>`：配置心跳检测 SQL，例如 `select user()`  
- `<writeHost>` / `<readHost>`：配置主库、从库的连接 URL、账号密码等信息

---

#### 3.3.4 rule.xml配置

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112205721741.png" alt="image-20260112205721741" style="zoom:50%;" />

`rule.xml` 中定义了 **所有拆分表的规则**。通过该文件，可以：

- 选择不同的分片算法
- 对同一分片算法配置不同参数

从而实现**分片过程的可配置化**。  
`rule.xml` 主要包含两类标签：

- **`tableRule`**
- **`function`**

常见用法示意（逻辑结构）：

- **`tableRule`**：  
  - 关联某个规则名称，例如 `auto-sharding-long`  
  - 指定使用哪个 `function` 作为实际分片算法  
- **`function`**：  
  - 定义具体的分片算法实现  
  - 可以是 range、取模、hash 等多种形式  

在 `schema.xml` 的 `<table>` 中，通过 `rule="xxx"` 就是引用这里定义的某个 `tableRule`。

---

#### 3.3.5 server.xml配置

需要在 `server.xml` 中配置用户名、密码，以及用户的访问权限信息。

**配置示例：**
```xml
<user name="root" defaultAccount="true">
    <property name="password">123456</property>
    <property name="schemas">DB01</property>
    <!-- 表级 DML 权限设置 -->
    <!--
    <privileges check="true">
        <schema name="DB01" dml="0110" >
            <table name="TB_ORDER" dml="1110"></table>
        </schema>
    </privileges>
    -->
</user>

<user name="user">
    <property name="password">123456</property>
    <property name="schemas">DB01</property>
    <property name="readOnly">true</property>
</user>
```

上述的配置表示，定义了两个用户 `root` 和 `user`，这两个用户都可以访问 `DB01` 这个逻辑库，访问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是user用户访问DB01逻辑库是只读的。

除了用户与权限外，`server.xml` 还包含了大量 **系统级配置**，主要由 `system` 和 `user` 两大类标签构成。

##### 1）`system` 标签 —— 系统参数

![image-20260112205746016](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112205746016.png)

`system` 标签中配置的是 MyCat 的系统级行为，例如字符集、端口、超时时间等。

下面用表格方式列出常见的重要属性（便于查表记忆）：

| **属性**                    | **典型取值**                | **含义说明**                                                 |
| --------------------------- | --------------------------- | ------------------------------------------------------------ |
| `charset`                   | `utf8`                      | 设置 MyCat 的字符集，需与 MySQL 字符集保持一致               |
| `nonePasswordLogin`         | `0` / `1`                   | 是否需要密码登录；`0` 需要密码（默认），`1` 不需要密码但需指定默认账户 |
| `useHandshakeV10`           | `0` / `1`                   | 是否采用 HandshakeV10Packet 与客户端通信，以兼容高版本 JDBC 驱动 |
| `useSqlStat`                | `0` / `1`                   | 是否开启 SQL 实时统计；开启后可通过 `show @@sql`、`show @@sql.slow`、`show @@sql.sum` 查看执行情况 |
| `useGlobleTableCheck`       | `0` / `1`                   | 是否开启全局表一致性检测                                     |
| `sqlExecuteTimeout`         | 数值（如 `300`、`1000`）    | SQL 语句执行的超时时间，单位为秒，超时会中断执行并关闭连接   |
| `sequnceHandlerType`        | `0` / `1` / `2`             | 全局序列类型：`0` 本地文件（默认，主要用于测试）、`1` 数据库方式、`2` 时间戳列方式 |
| `sequnceHandlerPattern`     | 正则表达式                  | 匹配带有 `MYCATSEQ` 或 `mycatseq` 的序列标识的正则（注意空格情况） |
| `subqueryRelationshipCheck` | `true` / `false`            | 子查询存在关联查询时，是否检查关联字段中是否包含分片字段，默认 `false` |
| `useCompression`            | `0` / `1`                   | 是否开启 MySQL 压缩协议；`0` 关闭，`1` 开启                  |
| `fakeMySQLVersion`          | `5.5` / `5.6` 等            | 设置对外模拟的 MySQL 版本号                                  |
| `defaultSqlParser`          | `druidparser` / `fdbparser` | 默认 SQL 解析器；MyCat 1.4 之后默认使用 `druidparser`，`fdbparser` 已废弃 |
| `processors`                | 整数                        | 指定系统可用线程数量（通常为 CPU 核心数 × 每核线程数），会影响 buffer 池和执行线程池大小 |
| `processorBufferChunk`      | 整数（字节，如 `4096`）     | 每次分配 Socket Direct Buffer 的大小，同时影响 BufferPool 长度 |
| `processorExecutor`         | 整数                        | `NIOProcessor` 上共享的业务线程池（businessExecutor）大小    |
| `packetHeaderSize`          | 整数（默认 `4`）            | MySQL 协议中的报文头长度，默认 4 字节                        |
| `maxPacketSize`             | 整数（默认 `16M`）          | MySQL 协议可以携带的数据最大大小                             |
| `idleTimeout`               | 分钟数（如 `30`）           | 连接空闲时间的超时时长，超时后连接会被关闭并回收             |
| `txIsolation`               | `1` / `2` / `3` / `4`       | 初始化前端连接的事务隔离级别：1 未提交读，2 提交读，3 可重复读（默认），4 可串行化 |
| `serverPort`                | `8066`                      | MyCat 数据访问端口，默认 8066                                |
| `managerPort`               | `9066`                      | MyCat 管理端口，默认 9066                                    |

##### 2）`user` 标签 —— 用户与权限

`user` 标签用于配置：

- 连接 MyCat 时使用的**用户名、密码**
- 用户可以访问的**逻辑库列表**
- 用户在逻辑库、逻辑表上的 **DML 权限（增删改查）**

在权限测试或控制时，只需将 `privileges` 标签的注释去掉即可生效。

- 在 `privileges` 下的 `schema` 标签的 `dml` 属性：  
  - 配置的是 **逻辑库级别** 的 DML 权限  
- 在 `schema` 下的 `table` 标签的 `dml` 属性：  
  - 配置的是 **逻辑表级别** 的 DML 权限  

一般 `dml` 按位控制增删改查，例如：  

- 某些课程、文档中约定：`dml="0110"` 表示允许**增、删**，不允许**查、改**（具体位含义以官方文档/课程约定为准）

综合前面的示例可以理解为：

- `root` 用户：  
  - 可以访问 `DB01` 逻辑库  
  - 读写权限均开放（可根据 `privileges` 做细粒度控制）
- `user` 用户：  
  - 访问 `DB01` 逻辑库  
  - `readOnly=true`，只能执行查询操作

---

### 3.4 MyCat测试

#### 3.4.1 启动MyCat

配置完毕后，先启动涉及到的3台分片服务器，然后启动MyCat服务器。切换到Mycat的安装目录，执行如下指令：

```bash
# 启动
bin/mycat start

# 停止
bin/mycat stop

# 查看状态
bin/mycat status

# 查看启动日志
tail -f logs/wrapper.log
```

Mycat启动之后，占用端口号 **8066**（数据访问端口）。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112204042600.png" alt="image-20260112204042600" style="zoom:50%;" />

#### 3.4.2 连接MyCat

通过如下指令，就可以连接并登陆MyCat：

```bash
mysql -h 192.168.200.210 -P 8066 -uroot -p123456
```

我们看到我们是通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议。

#### 3.4.3 数据测试

然后就可以在MyCat中来创建表，并往表结构中插入数据，查看数据在MySQL中的分布情况。

```sql
CREATE TABLE TB_ORDER (
    id BIGINT(20) NOT NULL,
    title VARCHAR(100) NOT NULL,
    PRIMARY KEY (id)
) ENGINE=INNODB DEFAULT CHARSET=utf8;

INSERT INTO TB_ORDER(id, title) VALUES(1, 'goods1');
INSERT INTO TB_ORDER(id, title) VALUES(2, 'goods2');
INSERT INTO TB_ORDER(id, title) VALUES(3, 'goods3');
INSERT INTO TB_ORDER(id, title) VALUES(5000000, 'goods5000000');
INSERT INTO TB_ORDER(id, title) VALUES(10000000, 'goods10000000');
INSERT INTO TB_ORDER(id, title) VALUES(10000001, 'goods10000001');
INSERT INTO TB_ORDER(id, title) VALUES(15000000, 'goods15000000');
INSERT INTO TB_ORDER(id, title) VALUES(15000001, 'goods15000001');
```

经过测试，我们发现，在往 `TB_ORDER` 表中插入数据时：

- 如果id的值在**1-500w**之间，数据将会存储在第一个分片数据库中
- 如果id的值在**500w-1000w**之间，数据将会存储在第二个分片数据库中
- 如果id的值在**1000w-1500w**之间，数据将会存储在第三个分片数据库中
- 如果id的值超出**1500w**，在插入数据时，将会报错

**为什么会出现这种现象？**

这是由逻辑表配置时的一个参数 `rule` 决定的，而这个参数配置的就是分片规则，关于分片规则的详细配置，在后面的章节中会详细讲解。

## 三、MyCat分片

### 3.5.1 垂直拆分

#### 3.5.1.1 场景

在业务系统中，涉及以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分，原有的数据库表如下。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211739919.png" alt="image-20260112211739919" style="zoom:50%;" />

现在考虑将其进行垂直分库操作，将商品相关的表拆分到一个数据库服务器，订单表拆分的一个数据库服务器，用户及省市区表拆分到一个服务器。最终结构如下：

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211747029.png" alt="image-20260112211747029" style="zoom:50%;" />

#### 3.5.1.2 准备

准备三台服务器，IP地址如图所示：

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211800802.png" alt="image-20260112211800802" style="zoom:50%;" />

并且在 `192.168.200.210`、`192.168.200.213`、`192.168.200.214` 上面创建数据库 `shopping`。

#### 3.5.1.3 配置

**1). schema.xml**

```xml
<schema name="SHOPPING" checkSQLschema="true" sqlMaxLimit="100">
    <table name="tb_goods_base" dataNode="dn1" primaryKey="id" />
    <table name="tb_goods_brand" dataNode="dn1" primaryKey="id" />
    <table name="tb_goods_cat" dataNode="dn1" primaryKey="id" />
    <table name="tb_goods_desc" dataNode="dn1" primaryKey="goods_id" />
    <table name="tb_goods_item" dataNode="dn1" primaryKey="id" />
    <table name="tb_order_item" dataNode="dn2" primaryKey="id" />
    <table name="tb_order_master" dataNode="dn2" primaryKey="order_id" />
    <table name="tb_order_pay_log" dataNode="dn2" primaryKey="out_trade_no" />
    <table name="tb_user" dataNode="dn3" primaryKey="id" />
    <table name="tb_user_address" dataNode="dn3" primaryKey="id" />
    <table name="tb_areas_provinces" dataNode="dn3" primaryKey="id"/>
    <table name="tb_areas_city" dataNode="dn3" primaryKey="id"/>
    <table name="tb_areas_region" dataNode="dn3" primaryKey="id"/>
</schema>

<dataNode name="dn1" dataHost="dhost1" database="shopping" />
<dataNode name="dn2" dataHost="dhost2" database="shopping" />
<dataNode name="dn3" dataHost="dhost3" database="shopping" />

<dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"
          writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"
          slaveThreshold="100">
    <heartbeat>select user()</heartbeat>
    <writeHost host="master" 
               url="jdbc:mysql://192.168.200.210:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
               user="root" password="1234" />
</dataHost>

<dataHost name="dhost2" maxCon="1000" minCon="10" balance="0"
          writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"
          slaveThreshold="100">
    <heartbeat>select user()</heartbeat>
    <writeHost host="master" 
               url="jdbc:mysql://192.168.200.213:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
               user="root" password="1234" />
</dataHost>

<dataHost name="dhost3" maxCon="1000" minCon="10" balance="0"
          writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"
          slaveThreshold="100">
    <heartbeat>select user()</heartbeat>
    <writeHost host="master" 
               url="jdbc:mysql://192.168.200.214:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8"
               user="root" password="1234" />
</dataHost>
```

**2). server.xml**

```xml
<user name="root" defaultAccount="true">
    <property name="password">123456</property>
    <property name="schemas">SHOPPING</property>
    <!-- 表级 DML 权限设置 -->
    <!--
    <privileges check="true">
        <schema name="DB01" dml="0110" >
            <table name="TB_ORDER" dml="1110"></table>
        </schema>
    </privileges>
    -->
</user>

<user name="user">
    <property name="password">123456</property>
    <property name="schemas">SHOPPING</property>
    <property name="readOnly">true</property>
</user>
```

#### 3.5.1.4 测试

**1). 上传测试SQL脚本到服务器的/root目录**

![image-20260112211816145](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211816145.png)

**2). 执行指令导入测试数据**

重新启动MyCat后，在mycat的命令行中，通过source指令导入表结构，以及对应的数据，查看数据分布情况。

```sql
source /root/shopping-table.sql
source /root/shopping-insert.sql
```

将表结构及对应的测试数据导入之后，可以检查一下各个数据库服务器中的表结构分布情况。检查是否和我们准备工作中规划的服务器一致。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211847584.png" alt="image-20260112211847584" style="zoom:50%;" />

**3). 查询用户的收件人及收件人地址信息(包含省、市、区)**

在MyCat的命令行中，当我们执行以下多表联查的SQL语句时，可以正常查询出数据。

```sql
select ua.user_id, ua.contact, p.province, c.city, r.area , ua.address 
from tb_user_address ua ,tb_areas_city c , tb_areas_provinces p ,tb_areas_region r
where ua.province_id = p.provinceid and ua.city_id = c.cityid and ua.town_id = r.areaid;
```

![image-20260112211900928](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211900928.png)

**4). 查询每一笔订单及订单的收件地址信息(包含省、市、区)**

实现该需求对应的SQL语句如下：

```sql
SELECT order_id , payment ,receiver, province , city , area 
FROM tb_order_master o , tb_areas_provinces p , tb_areas_city c , tb_areas_region r 
WHERE o.receiver_province = p.provinceid AND o.receiver_city = c.cityid AND o.receiver_region = r.areaid;
```

但是现在存在一个问题，订单相关的表结构是在 `192.168.200.213` 数据库服务器中，而省市区的数据库表是在 `192.168.200.214` 数据库服务器中。那么在MyCat中执行是否可以成功呢？

![image-20260112211911211](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211911211.png)

经过测试，我们看到，SQL语句执行报错。原因就是因为MyCat在执行该SQL语句时，需要往具体的数据库服务器中路由，而当前没有一个数据库服务器完全包含了订单以及省市区的表结构，造成SQL语句失败，报错。

对于上述的这种现象，我们如何来解决呢？下面我们介绍的全局表，就可以轻松解决这个问题。

#### 3.5.1.5 全局表

对于省、市、区/县表 `tb_areas_provinces`、`tb_areas_city`、`tb_areas_region`，是属于数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。

修改 `schema.xml` 中的逻辑表的配置，修改 `tb_areas_provinces`、`tb_areas_city`、`tb_areas_region` 三个逻辑表，增加 `type` 属性，配置为 `global`，就代表该表是全局表，就会在所涉及到的 `dataNode` 中创建该表。对于当前配置来说，也就意味着所有的节点中都有该表了。

```xml
<table name="tb_areas_provinces" dataNode="dn1,dn2,dn3" primaryKey="id" type="global"/>
<table name="tb_areas_city" dataNode="dn1,dn2,dn3" primaryKey="id" type="global"/>
<table name="tb_areas_region" dataNode="dn1,dn2,dn3" primaryKey="id" type="global"/>
```

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211930017.png" alt="image-20260112211930017" style="zoom:67%;" />

配置完毕后，重新启动MyCat。

**1). 删除原来每一个数据库服务器中的所有表结构**

**2). 通过source指令，导入表及数据**

```sql
source /root/shopping-table.sql
source /root/shopping-insert.sql
```

**3). 检查每一个数据库服务器中的表及数据分布，看到三个节点中都有这三张全局表**

**4). 然后再次执行上面的多表联查的SQL语句**

```sql
SELECT order_id , payment ,receiver, province , city , area 
FROM tb_order_master o , tb_areas_provinces p , tb_areas_city c , tb_areas_region r 
WHERE o.receiver_province = p.provinceid AND o.receiver_city = c.cityid AND o.receiver_region = r.areaid;
```

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112211954715.png" alt="image-20260112211954715" style="zoom:50%;" />

是可以正常执行成功的。

**5). 当在MyCat中更新全局表的时候，我们可以看到，所有分片节点中的数据都发生了变化，每个节点的全局表数据时刻保持一致。**

### 3.5.2 水平拆分

#### 3.5.2.1 场景

在业务系统中，有一张表(日志表)，业务系统每天都会产生大量的日志数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212007015.png" alt="image-20260112212007015" style="zoom:50%;" />

#### 3.5.2.2 准备

准备三台服务器，具体的结构如下：

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212014901.png" alt="image-20260112212014901" style="zoom:50%;" />

并且，在三台数据库服务器中分别创建一个数据库 `itcast`。

#### 3.5.2.3 配置

**1). schema.xml**

```xml
<schema name="ITCAST" checkSQLschema="true" sqlMaxLimit="100">
    <table name="tb_log" dataNode="dn4,dn5,dn6" primaryKey="id" rule="mod-long" />
</schema>

<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

`tb_log` 表最终落在3个节点中，分别是 `dn4`、`dn5`、`dn6`，而具体的数据分别存储在 `dhost1`、`dhost2`、`dhost3` 的 `itcast` 数据库中。

**2). server.xml**

配置root用户既可以访问 `SHOPPING` 逻辑库，又可以访问 `ITCAST` 逻辑库。

```xml
<user name="root" defaultAccount="true">
    <property name="password">123456</property>
    <property name="schemas">SHOPPING,ITCAST</property>
    <!-- 表级 DML 权限设置 -->
    <!--
    <privileges check="true">
        <schema name="DB01" dml="0110" >
            <table name="TB_ORDER" dml="1110"></table>
        </schema>
    </privileges>
    -->
</user>
```

#### 3.5.2.4 测试

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
CREATE TABLE tb_log (
    id bigint(20) NOT NULL COMMENT 'ID',
    model_name varchar(200) DEFAULT NULL COMMENT '模块名',
    model_value varchar(200) DEFAULT NULL COMMENT '模块值',
    return_value varchar(200) DEFAULT NULL COMMENT '返回值',
    return_class varchar(200) DEFAULT NULL COMMENT '返回值类型',
    operate_user varchar(20) DEFAULT NULL COMMENT '操作用户',
    operate_time varchar(20) DEFAULT NULL COMMENT '操作时间',
    param_and_value varchar(500) DEFAULT NULL COMMENT '请求参数名及参数值',
    operate_class varchar(200) DEFAULT NULL COMMENT '操作类',
    operate_method varchar(200) DEFAULT NULL COMMENT '操作方法',
    cost_time bigint(20) DEFAULT NULL COMMENT '执行方法耗时, 单位 ms',
    source int(1) DEFAULT NULL COMMENT '来源 : 1 PC , 2 Android , 3 IOS',
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO tb_log (id, model_name, model_value, return_value, return_class,
operate_user, operate_time, param_and_value, operate_class, operate_method,
cost_time, source)
VALUES('1','user','insert','success','java.lang.String','10001','2022-01-06 18:12:28',
'{\"age\":\"20\",\"name\":\"Tom\",\"gender\":\"1\"}','cn.itcast.controller.UserController','insert','10',1);

INSERT INTO tb_log (id, model_name, model_value, return_value, return_class,
operate_user, operate_time, param_and_value, operate_class, operate_method,
cost_time, source)
VALUES('2','user','insert','success','java.lang.String','10001','2022-01-06 18:12:27',
'{\"age\":\"20\",\"name\":\"Tom\",\"gender\":\"1\"}','cn.itcast.controller.UserController','insert','23',1);

INSERT INTO tb_log (id, model_name, model_value, return_value, return_class,
operate_user, operate_time, param_and_value, operate_class, operate_method,
cost_time, source)
VALUES('3','user','update','success','java.lang.String','10001','2022-01-06 18:16:45',
'{\"age\":\"20\",\"name\":\"Tom\",\"gender\":\"1\"}','cn.itcast.controller.UserController','update','34',1);

INSERT INTO tb_log (id, model_name, model_value, return_value, return_class,
operate_user, operate_time, param_and_value, operate_class, operate_method,
cost_time, source)
VALUES('4','user','update','success','java.lang.String','10001','2022-01-06 18:16:45',
'{\"age\":\"20\",\"name\":\"Tom\",\"gender\":\"1\"}','cn.itcast.controller.UserController','update','13',2);

INSERT INTO tb_log (id, model_name, model_value, return_value, return_class,
operate_user, operate_time, param_and_value, operate_class, operate_method,
cost_time, source)
VALUES('5','user','insert','success','java.lang.String','10001','2022-01-06 18:30:31',
'{\"age\":\"200\",\"name\":\"TomCat\",\"gender\":\"0\"}','cn.itcast.controller.UserController','insert','29',3);

INSERT INTO tb_log (id, model_name, model_value, return_value, return_class,
operate_user, operate_time, param_and_value, operate_class, operate_method,
cost_time, source)
VALUES('6','user','find','success','java.lang.String','10001','2022-01-06 18:30:31',
'{\"age\":\"200\",\"name\":\"TomCat\",\"gender\":\"0\"}','cn.itcast.controller.UserController','find','29',2);
```

### 3.5.3 分片规则

#### 3.5.3.1 范围分片

**1). 介绍**

根据指定的字段及其配置的范围与数据节点的对应情况，来决定该数据属于哪一个分片。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212035029.png" alt="image-20260112212035029" style="zoom:50%;" />

**2). 配置**

**schema.xml逻辑表配置：**

```xml
<table name="TB_ORDER" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
```

**schema.xml数据节点配置：**

```xml
<dataNode name="dn1" dataHost="dhost1" database="db01" />
<dataNode name="dn2" dataHost="dhost2" database="db01" />
<dataNode name="dn3" dataHost="dhost3" database="db01" />
```

**rule.xml分片规则配置：**

```xml
<tableRule name="auto-sharding-long">
    <rule>
        <columns>id</columns>
        <algorithm>rang-long</algorithm>
    </rule>
</tableRule>

<function name="rang-long" class="io.mycat.route.function.AutoPartitionByLong">
    <property name="mapFile">autopartition-long.txt</property>
    <property name="defaultNode">0</property>
</function>
```

**分片规则配置属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| mapFile | 对应的外部配置文件 |
| type | 默认值为0；0 表示Integer，1 表示String |
| defaultNode | 默认节点；默认节点的作用：枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点；如果没有默认值，碰到不识别的则报错 |

在 `rule.xml` 中配置分片规则时，关联了一个映射配置文件 `autopartition-long.txt`，该配置文件的配置如下：

```
# range start-end ,data node index
# K=1000,M=10000.
0-500M=0
500M-1000M=1
1000M-1500M=2
```

含义：0-500万之间的值，存储在0号数据节点(数据节点的索引从0开始)；500万-1000万之间的数据存储在1号数据节点；1000万-1500万的数据节点存储在2号节点。

该分片规则，主要是针对于数字类型的字段适用。在MyCat的入门程序中，我们使用的就是该分片规则。

#### 3.5.3.2 取模分片

**1). 介绍**

根据指定的字段值与节点数量进行求模运算，根据运算结果，来决定该数据属于哪一个分片。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212053131.png" alt="image-20260112212053131" style="zoom:50%;" />

**2). 配置**

**schema.xml逻辑表配置：**

```xml
<table name="tb_log" dataNode="dn4,dn5,dn6" primaryKey="id" rule="mod-long" />
```

**schema.xml数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml分片规则配置：**

```xml
<tableRule name="mod-long">
    <rule>
        <columns>id</columns>
        <algorithm>mod-long</algorithm>
    </rule>
</tableRule>

<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
    <property name="count">3</property>
</function>
```

**分片规则属性说明如下：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| count | 数据节点的数量 |

该分片规则，主要是针对于数字类型的字段适用。在前面水平拆分的演示中，我们选择的就是取模分片。

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

#### 3.5.3.3 一致性hash分片

**1). 介绍**

所谓一致性哈希，相同的哈希因子计算值总是被划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置，有效的解决了分布式数据的拓容问题。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212127138.png" alt="image-20260112212127138" style="zoom:50%;" />

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 一致性hash -->
<table name="tb_order" dataNode="dn4,dn5,dn6" rule="sharding-by-murmur" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-murmur">
    <rule>
        <columns>id</columns>
        <algorithm>murmur</algorithm>
    </rule>
</tableRule>

<function name="murmur" class="io.mycat.route.function.PartitionByMurmurHash">
    <property name="seed">0</property><!-- 默认是0 -->
    <property name="count">3</property>
    <property name="virtualBucketTimes">160</property>
</function>
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| seed | 创建murmur_hash对象的种子，默认0 |
| count | 要分片的数据库节点数量，必须指定，否则没法分片 |
| virtualBucketTimes | 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍；virtualBucketTimes*count就是虚拟结点数量 |
| weightMapFile | 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 |
| bucketMapPath | 用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 |

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
create table tb_order(
    id varchar(100) not null primary key,
    money int null,
    content varchar(200) null
);

INSERT INTO tb_order (id, money, content) VALUES ('b92fdaaf-6fc4-11ec-b831-482ae33c4a2d', 10, 'b92fdaf8-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b93482b6-6fc4-11ec-b831-482ae33c4a2d', 20, 'b93482d5-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b937e246-6fc4-11ec-b831-482ae33c4a2d', 50, 'b937e25d-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b93be2dd-6fc4-11ec-b831-482ae33c4a2d', 100, 'b93be2f9-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b93f2d68-6fc4-11ec-b831-482ae33c4a2d', 130, 'b93f2d7d-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b9451b98-6fc4-11ec-b831-482ae33c4a2d', 30, 'b9451bcc-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b9488ec1-6fc4-11ec-b831-482ae33c4a2d', 560, 'b9488edb-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b94be6e6-6fc4-11ec-b831-482ae33c4a2d', 10, 'b94be6ff-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b94ee10d-6fc4-11ec-b831-482ae33c4a2d', 123, 'b94ee12c-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b952492a-6fc4-11ec-b831-482ae33c4a2d', 145, 'b9524945-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b95553ac-6fc4-11ec-b831-482ae33c4a2d', 543, 'b95553c8-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b9581cdd-6fc4-11ec-b831-482ae33c4a2d', 17, 'b9581cfa-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b95afc0f-6fc4-11ec-b831-482ae33c4a2d', 18, 'b95afc2a-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b95daa99-6fc4-11ec-b831-482ae33c4a2d', 134, 'b95daab2-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b9667e3c-6fc4-11ec-b831-482ae33c4a2d', 156, 'b9667e60-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b96ab489-6fc4-11ec-b831-482ae33c4a2d', 175, 'b96ab4a5-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b96e2942-6fc4-11ec-b831-482ae33c4a2d', 180, 'b96e295b-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b97092ec-6fc4-11ec-b831-482ae33c4a2d', 123, 'b9709306-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b973727a-6fc4-11ec-b831-482ae33c4a2d', 230, 'b9737293-6fc4-11ec-b831-482ae33c4a2d');
INSERT INTO tb_order (id, money, content) VALUES ('b978840f-6fc4-11ec-b831-482ae33c4a2d', 560, 'b978843c-6fc4-11ec-b831-482ae33c4a2d');
```

#### 3.5.3.4 枚举分片

**1). 介绍**

通过在配置文件中配置可能的枚举值，指定数据分布到不同数据节点上，本规则适用于按照省份、性别、状态拆分数据等业务。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212144698.png" alt="image-20260112212144698" style="zoom:50%;" />

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 枚举 -->
<table name="tb_user" dataNode="dn4,dn5,dn6" rule="sharding-by-intfile-enumstatus" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-intfile">
    <rule>
        <columns>sharding_id</columns>
        <algorithm>hash-int</algorithm>
    </rule>
</tableRule>

<!-- 自己增加 tableRule -->
<tableRule name="sharding-by-intfile-enumstatus">
    <rule>
        <columns>status</columns>
        <algorithm>hash-int</algorithm>
    </rule>
</tableRule>

<function name="hash-int" class="io.mycat.route.function.PartitionByFileMap">
    <property name="defaultNode">2</property>
    <property name="mapFile">partition-hash-int.txt</property>
</function>
```

`partition-hash-int.txt`，内容如下：

```
1=0
2=1
3=2
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| mapFile | 对应的外部配置文件 |
| type | 默认值为0；0 表示Integer，1 表示String |
| defaultNode | 默认节点；小于0 标识不设置默认节点，大于等于0代表设置默认节点；默认节点的作用：枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点；如果没有默认值，碰到不识别的则报错 |

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
CREATE TABLE tb_user (
    id bigint(20) NOT NULL COMMENT 'ID',
    username varchar(200) DEFAULT NULL COMMENT '姓名',
    status int(2) DEFAULT '1' COMMENT '1: 未启用, 2: 已启用, 3: 已关闭',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

insert into tb_user (id,username ,status) values(1,'Tom',1);
insert into tb_user (id,username ,status) values(2,'Cat',2);
insert into tb_user (id,username ,status) values(3,'Rose',3);
insert into tb_user (id,username ,status) values(4,'Coco',2);
insert into tb_user (id,username ,status) values(5,'Lily',1);
insert into tb_user (id,username ,status) values(6,'Tom',1);
insert into tb_user (id,username ,status) values(7,'Cat',2);
insert into tb_user (id,username ,status) values(8,'Rose',3);
insert into tb_user (id,username ,status) values(9,'Coco',2);
insert into tb_user (id,username ,status) values(10,'Lily',1);
```

#### 3.5.3.5 应用指定算法

**1). 介绍**

运行阶段由应用自主决定路由到那个分片，直接根据字符子串（必须是数字）计算分片号。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212200201.png" alt="image-20260112212200201" style="zoom:50%;" />

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 应用指定算法 -->
<table name="tb_app" dataNode="dn4,dn5,dn6" rule="sharding-by-substring" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-substring">
    <rule>
        <columns>id</columns>
        <algorithm>sharding-by-substring</algorithm>
    </rule>
</tableRule>

<function name="sharding-by-substring"
          class="io.mycat.route.function.PartitionDirectBySubString">
    <property name="startIndex">0</property> <!-- zero-based -->
    <property name="size">2</property>
    <property name="partitionCount">3</property>
    <property name="defaultPartition">0</property>
</function>
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| startIndex | 字符子串起始索引 |
| size | 字符长度 |
| partitionCount | 分区(分片)数量 |
| defaultPartition | 默认分片(在分片数量定义时，字符标示的分片编号不在分片数量内时，使用默认分片) |

**示例说明：**

`id=05-100000002`，在此配置中代表根据id中从 `startIndex=0`，开始，截取 `size=2` 位数字即 `05`，`05` 就是获取的分区，如果没找到对应的分片则默认分配到 `defaultPartition`。

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
CREATE TABLE tb_app (
    id varchar(10) NOT NULL COMMENT 'ID',
    name varchar(200) DEFAULT NULL COMMENT '名称',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

insert into tb_app (id,name) values('0000001','Testx00001');
insert into tb_app (id,name) values('0100001','Test100001');
insert into tb_app (id,name) values('0100002','Test200001');
insert into tb_app (id,name) values('0200001','Test300001');
insert into tb_app (id,name) values('0200002','TesT400001');
```

#### 3.5.3.6 固定分片hash算法

**1). 介绍**

该算法类似于十进制的求模运算，但是为二进制的操作，例如，取 id 的二进制低 10 位 与 `1111111111` 进行位 & 运算，位与运算最小值为 `0000000000`，最大值为 `1111111111`，转换为十进制，也就是位于0-1023之间。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212212597.png" alt="image-20260112212212597" style="zoom:50%;" />

**特点：**

- 如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。
- 可以均匀分配，也可以非均匀分配。
- 分片字段必须为数字类型。

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 固定分片hash算法 -->
<table name="tb_longhash" dataNode="dn4,dn5,dn6" rule="sharding-by-long-hash" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-long-hash">
    <rule>
        <columns>id</columns>
        <algorithm>sharding-by-long-hash</algorithm>
    </rule>
</tableRule>

<!-- 分片总长度为1024，count与length数组长度必须一致； -->
<function name="sharding-by-long-hash"
          class="io.mycat.route.function.PartitionByLong">
    <property name="partitionCount">2,1</property>
    <property name="partitionLength">256,512</property>
</function>
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段名 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| partitionCount | 分片个数列表 |
| partitionLength | 分片范围列表 |

**约束：**

1. 分片长度：默认最大2^10，为 1024
2. count、length的数组长度必须是一致的

以上分为三个分区：0-255,256-511,512-1023

**示例说明：**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212223569.png" alt="image-20260112212223569" style="zoom:50%;" />

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
CREATE TABLE tb_longhash (
    id int(11) NOT NULL COMMENT 'ID',
    name varchar(200) DEFAULT NULL COMMENT '名称',
    firstChar char(1) COMMENT '首字母',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

insert into tb_longhash (id,name,firstChar) values(1,'七匹狼','Q');
insert into tb_longhash (id,name,firstChar) values(2,'八匹狼','B');
insert into tb_longhash (id,name,firstChar) values(3,'九匹狼','J');
insert into tb_longhash (id,name,firstChar) values(4,'十匹狼','S');
insert into tb_longhash (id,name,firstChar) values(5,'六匹狼','L');
insert into tb_longhash (id,name,firstChar) values(6,'五匹狼','W');
insert into tb_longhash (id,name,firstChar) values(7,'四匹狼','S');
insert into tb_longhash (id,name,firstChar) values(8,'三匹狼','S');
insert into tb_longhash (id,name,firstChar) values(9,'两匹狼','L');
```

#### 3.5.3.7 字符串hash解析算法

**1). 介绍**

截取字符串中的指定位置的子字符串，进行hash算法，算出分片。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212233906.png" alt="image-20260112212233906" style="zoom:50%;" />

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 字符串hash解析算法 -->
<table name="tb_strhash" dataNode="dn4,dn5" rule="sharding-by-stringhash" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-stringhash">
    <rule>
        <columns>name</columns>
        <algorithm>sharding-by-stringhash</algorithm>
    </rule>
</tableRule>

<function name="sharding-by-stringhash"
          class="io.mycat.route.function.PartitionByString">
    <property name="partitionLength">512</property> <!-- zero-based -->
    <property name="partitionCount">2</property>
    <property name="hashSlice">0:2</property>
</function>
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| partitionLength | hash求模基数；length*count=1024 (出于性能考虑) |
| partitionCount | 分区数 |
| hashSlice | hash运算位，根据子字符串的hash运算；0 代表 str.length()，-1 代表 str.length()-1，大于0只代表数字自身；可以理解为substring（start，end），start为0则只表示0 |

**示例说明：**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212251303.png" alt="image-20260112212251303" style="zoom:50%;" />

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
create table tb_strhash(
    name varchar(20) primary key,
    content varchar(100)
)engine=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO tb_strhash (name,content) VALUES('T1001', UUID());
INSERT INTO tb_strhash (name,content) VALUES('ROSE', UUID());
INSERT INTO tb_strhash (name,content) VALUES('JERRY', UUID());
INSERT INTO tb_strhash (name,content) VALUES('CRISTINA', UUID());
INSERT INTO tb_strhash (name,content) VALUES('TOMCAT', UUID());
```

#### 3.5.3.8 按天分片算法

**1). 介绍**

按照日期及对应的时间周期来分片。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212302198.png" alt="image-20260112212302198" style="zoom:50%;" />

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 按天分片 -->
<table name="tb_datepart" dataNode="dn4,dn5,dn6" rule="sharding-by-date" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-date">
    <rule>
        <columns>create_time</columns>
        <algorithm>sharding-by-date</algorithm>
    </rule>
</tableRule>

<function name="sharding-by-date"
          class="io.mycat.route.function.PartitionByDate">
    <property name="dateFormat">yyyy-MM-dd</property>
    <property name="sBeginDate">2022-01-01</property>
    <property name="sEndDate">2022-01-30</property>
    <property name="sPartionDay">10</property>
</function>
<!--
从开始时间开始，每10天为一个分片，到达结束时间之后，会重复开始分片插入
配置表的 dataNode 的分片，必须和分片规则数量一致，例如 2022-01-01 到 2022-12-31 ，每10天一个分片，一共需要37个分片。
-->
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| dateFormat | 日期格式 |
| sBeginDate | 开始日期 |
| sEndDate | 结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入 |
| sPartionDay | 分区天数，默认值 10，从开始日期算起，每个10天一个分区 |

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
create table tb_datepart(
    id bigint not null comment 'ID' primary key,
    name varchar(100) null comment '姓名',
    create_time date null
);

insert into tb_datepart(id,name ,create_time) values(1,'Tom','2022-01-01');
insert into tb_datepart(id,name ,create_time) values(2,'Cat','2022-01-10');
insert into tb_datepart(id,name ,create_time) values(3,'Rose','2022-01-11');
insert into tb_datepart(id,name ,create_time) values(4,'Coco','2022-01-20');
insert into tb_datepart(id,name ,create_time) values(5,'Rose2','2022-01-21');
insert into tb_datepart(id,name ,create_time) values(6,'Coco2','2022-01-30');
insert into tb_datepart(id,name ,create_time) values(7,'Coco3','2022-01-31');
```

#### 3.5.3.9 自然月分片

**1). 介绍**

使用场景为按照月份来分片，每个自然月为一个分片。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212323551.png" alt="image-20260112212323551" style="zoom:50%;" />

**2). 配置**

**schema.xml中逻辑表配置：**

```xml
<!-- 按自然月分片 -->
<table name="tb_monthpart" dataNode="dn4,dn5,dn6" rule="sharding-by-month" />
```

**schema.xml中数据节点配置：**

```xml
<dataNode name="dn4" dataHost="dhost1" database="itcast" />
<dataNode name="dn5" dataHost="dhost2" database="itcast" />
<dataNode name="dn6" dataHost="dhost3" database="itcast" />
```

**rule.xml中分片规则配置：**

```xml
<tableRule name="sharding-by-month">
    <rule>
        <columns>create_time</columns>
        <algorithm>partbymonth</algorithm>
    </rule>
</tableRule>

<function name="partbymonth" class="io.mycat.route.function.PartitionByMonth">
    <property name="dateFormat">yyyy-MM-dd</property>
    <property name="sBeginDate">2022-01-01</property>
    <property name="sEndDate">2022-03-31</property>
</function>
<!--
从开始时间开始，一个月为一个分片，到达结束时间之后，会重复开始分片插入
配置表的 dataNode 的分片，必须和分片规则数量一致，例如 2022-01-01 到 2022-12-31 ，一共需要12个分片。
-->
```

**分片规则属性含义：**

| 属性 | 描述 |
|------|------|
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与function的对应关系 |
| class | 指定该分片算法对应的类 |
| dateFormat | 日期格式 |
| sBeginDate | 开始日期 |
| sEndDate | 结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入 |

**3). 测试**

配置完毕后，重新启动MyCat，然后在mycat的命令行中，执行如下SQL创建表、并插入数据，查看数据分布情况。

```sql
create table tb_monthpart(
    id bigint not null comment 'ID' primary key,
    name varchar(100) null comment '姓名',
    create_time date null
);

insert into tb_monthpart(id,name ,create_time) values(1,'Tom','2022-01-01');
insert into tb_monthpart(id,name ,create_time) values(2,'Cat','2022-01-10');
insert into tb_monthpart(id,name ,create_time) values(3,'Rose','2022-01-31');
insert into tb_monthpart(id,name ,create_time) values(4,'Coco','2022-02-20');
insert into tb_monthpart(id,name ,create_time) values(5,'Rose2','2022-02-25');
insert into tb_monthpart(id,name ,create_time) values(6,'Coco2','2022-03-10');
insert into tb_monthpart(id,name ,create_time) values(7,'Coco3','2022-03-31');
insert into tb_monthpart(id,name ,create_time) values(8,'Coco4','2022-04-10');
insert into tb_monthpart(id,name ,create_time) values(9,'Coco5','2022-04-30');
```

## 四、MyCat管理及监控

### 3.6.1 MyCat原理

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212337850.png" alt="image-20260112212337850" style="zoom:50%;" />

在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。

而在MyCat的使用过程中，MyCat官方也提供了一个管理监控平台MyCat-Web（MyCat-eye）。

Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。

### 3.6.2 MyCat管理

Mycat默认开通2个端口，可以在 `server.xml` 中进行修改。

- **8066** 数据访问端口，即进行 DML 和 DDL 操作。
- **9066** 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态

连接MyCat的管理控制台：

```bash
mysql -h 192.168.200.210 -p 9066 -uroot -p123456
```

| 命令 | 含义 |
|------|------|
| `show @@help` | 查看Mycat管理工具帮助文档 |
| `show @@version` | 查看Mycat的版本 |
| `reload @@config` | 重新加载Mycat的配置文件 |
| `show @@datasource` | 查看Mycat的数据源信息 |
| `show @@datanode` | 查看MyCat现有的分片节点信息 |
| `show @@threadpool` | 查看Mycat的线程池信息 |
| `show @@sql` | 查看执行的SQL |
| `show @@sql.sum` | 查看执行的SQL统计 |

### 3.6.3 MyCat-eye

#### 3.6.3.1 介绍

Mycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使用。他通过JDBC连接对Mycat、Mysql监控，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。

Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。

#### 3.6.3.2 安装

**1). zookeeper安装**

**2). Mycat-web安装**

具体的安装步骤，请参考资料中提供的《MyCat-Web安装文档》

#### 3.6.3.3 访问

```
http://192.168.200.210:8082/mycat
```

![image-20260112212403250](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212403250.png)

#### 3.6.3.4 配置

**1). 开启MyCat的实时统计功能(server.xml)**

```xml
<property name="useSqlStat">1</property> <!-- 1为开启实时统计、0为关闭 -->
```

**2). 在Mycat监控界面配置服务地址**

![image-20260112212414468](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212414468.png)

#### 3.6.3.5 测试

配置好了之后，我们可以通过MyCat执行一系列的增删改查的测试，然后过一段时间之后，打开mycat-eye的管理界面，查看mycat-eye监控到的数据信息。

**A. 性能监控**

![image-20260112212422010](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212422010.png)

**B. 物理节点**

![image-20260112212429386](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212429386.png)

**C. SQL统计**

![image-20260112212436022](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212436022.png)

**D. SQL表分析**

![image-20260112212441876](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212441876.png)

**E. SQL监控**

![image-20260112212448048](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212448048.png)

**F. 高频SQL**

![image-20260112212454303](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112212454303.png)

---

**上一章：** [主从复制](/tutorials/java-backend/mysql/第05章-运维篇/02-主从复制/)

**下一章：** [读写分离](/tutorials/java-backend/mysql/第05章-运维篇/04-读写分离/) →
