---
title: 事务管理
prevChapter: "java-backend/mysql/第02章-进阶篇/03-多表查询与连接"
parentChapter: "java-backend/mysql/README"
---
# 事务管理

> 事务是数据库的核心特性之一，确保数据的一致性和可靠性。本章将深入学习事务的原理和使用，掌握事务管理是构建可靠数据库应用的基础。

## ⚡ 快速参考

- **事务定义**：一组操作的集合，要么全部成功，要么全部失败（原子性）
- **ACID特性**：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
- **事务操作**：START TRANSACTION（开启）、COMMIT（提交）、ROLLBACK（回滚）
- **隔离级别**：READ UNCOMMITTED（读未提交）、READ COMMITTED（读已提交）、REPEATABLE READ（可重复读，MySQL默认）、SERIALIZABLE（串行化）
- **并发问题**：脏读（Dirty Read）、不可重复读（Non-Repeatable Read）、幻读（Phantom Read）
- **应用场景**：转账、订单、库存扣减、批量操作等需要保证数据一致性的业务

## 📚 学习目标

1. 理解事务的概念和作用，掌握事务在保证数据一致性中的重要性
2. 深入理解ACID四大特性的含义和应用场景
3. 熟练掌握事务的基本操作（开启、提交、回滚）
4. 理解事务隔离级别的概念，掌握四种隔离级别的区别
5. 理解并发事务可能产生的问题（脏读、不可重复读、幻读）
6. 能够根据业务需求选择合适的隔离级别
7. 掌握事务在实际业务场景中的应用（如银行转账、订单处理等）
8. 理解事务对数据库性能的影响，掌握事务优化技巧

## 一、事务概述

### 1.1 什么是事务？

**事务（Transaction）** 是一组操作的集合，是一个不可分割的工作单位。事务会将所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

### 1.2 为什么需要事务？

**经典场景：银行转账**

![image-20260111194241520](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194241520.png)

```sql
-- 张三给李四转账1000元
-- 步骤1：张三账户-1000
UPDATE account SET balance = balance - 1000 WHERE name = '张三';

-- 步骤2：李四账户+1000
UPDATE account SET balance = balance + 1000 WHERE name = '李四';
```

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194257116.png" alt="image-20260111194257116" style="zoom:50%;" />

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194312045.png" alt="image-20260111194312045" style="zoom:50%;" />

**问题**：如果步骤1成功但步骤2失败（如系统崩溃），会导致：

- ❌ 张三少了1000元
- ❌ 李四没有收到1000元
- ❌ 钱凭空消失了！

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194323688.png" alt="image-20260111194323688" style="zoom:50%;" />

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194330321.png" alt="image-20260111194330321" style="zoom:50%;" />

**解决方案**：使用事务

- ✅ 两个操作要么都成功
- ✅ 要么都失败回滚
- ✅ 保证数据一致性

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194345170.png" alt="image-20260111194345170" style="zoom:50%;" />

注意：默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。

### 1.3 实际工作中什么时候用事务？

**场景1：电商下单（最常见）**
```sql
START TRANSACTION;
-- 1. 创建订单
INSERT INTO orders (user_id, total_amount) VALUES (1001, 299.00);
-- 2. 扣减库存
UPDATE products SET stock = stock - 1 WHERE product_id = 5001;
-- 3. 扣减用户余额
UPDATE users SET balance = balance - 299.00 WHERE user_id = 1001;
-- 4. 记录积分
INSERT INTO points_log (user_id, points) VALUES (1001, 29);
COMMIT;
```
**为什么用事务**：四个操作必须全部成功，任何一步失败都要回滚，否则会出现：订单创建了但没扣库存、钱扣了但订单没创建等数据不一致问题。

**场景2：秒杀抢购**
```sql
START TRANSACTION;
-- 检查库存并锁定
SELECT stock FROM products WHERE id = 1001 FOR UPDATE;
-- 如果有库存，扣减
UPDATE products SET stock = stock - 1 WHERE id = 1001 AND stock > 0;
-- 创建订单
INSERT INTO orders (user_id, product_id) VALUES (1001, 1001);
COMMIT;
```
**为什么用事务**：防止超卖。`FOR UPDATE` 加排他锁，确保并发情况下不会出现库存为负的情况。

**场景3：用户注册**
```sql
START TRANSACTION;
-- 1. 创建用户账户
INSERT INTO users (username, password, email) VALUES ('zhangsan', '***', 'zs@example.com');
-- 2. 初始化用户钱包
INSERT INTO wallets (user_id, balance) VALUES (LAST_INSERT_ID(), 0);
-- 3. 赠送新人优惠券
INSERT INTO coupons (user_id, coupon_code) VALUES (LAST_INSERT_ID(), 'NEW100');
COMMIT;
```
**为什么用事务**：注册流程涉及多个表，必须保证要么全部创建成功，要么全部失败。

**场景4：订单退款**
```sql
START TRANSACTION;
-- 1. 更新订单状态
UPDATE orders SET status = 'REFUNDED' WHERE order_id = 12345;
-- 2. 恢复库存
UPDATE products SET stock = stock + quantity FROM order_items WHERE order_id = 12345;
-- 3. 退款到用户账户
UPDATE users SET balance = balance + refund_amount WHERE user_id = 1001;
-- 4. 记录退款日志
INSERT INTO refund_logs (order_id, amount, refund_time) VALUES (12345, 299.00, NOW());
COMMIT;
```
**为什么用事务**：退款涉及订单、库存、资金、日志等多个操作，必须保证数据一致性。

**场景5：批量转账（财务系统）**
```sql
START TRANSACTION;
-- 工资发放：从公司账户转到多个员工账户
UPDATE company_account SET balance = balance - 100000 WHERE id = 1;
UPDATE employee_accounts SET balance = balance + 5000 WHERE dept = 'IT';
UPDATE salary_records SET status = 'PAID' WHERE month = '2024-01';
COMMIT;
```

**不需要事务的场景：**
- ❌ 简单的单表查询：`SELECT * FROM users WHERE id = 1`
- ❌ 单条数据的插入（无关联操作）：`INSERT INTO logs (...)`
- ❌ 统计查询：`SELECT COUNT(*) FROM orders`
- ❌ 读多写少的日志表

**需要事务的判断标准：**
1. ✅ 涉及多个表的操作
2. ✅ 涉及金额、库存等关键数据
3. ✅ 需要保证数据一致性
4. ✅ 有业务上的原子性要求
5. ✅ 并发操作需要加锁

---

## 二、事务的ACID特性

事务必须满足4个特性，简称**ACID**：

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194546723.png" alt="image-20260111194546723" style="zoom:50%;" />

### 2.1 原子性（Atomicity）

事务是不可分割的最小操作单元，**要么全部成功，要么全部失败**。

**示例：**
```sql
START TRANSACTION;
UPDATE account SET balance = balance - 1000 WHERE name = '张三';  -- 操作1
UPDATE account SET balance = balance + 1000 WHERE name = '李四';  -- 操作2
COMMIT;  -- 两个操作都成功

-- 如果中途出错
ROLLBACK;  -- 两个操作都回滚
```

### 2.2 一致性（Consistency）

事务完成时，必须使所有数据都保持**一致状态**。

**示例：**
- 转账前：张三1000 + 李四2000 = 3000
- 转账后：张三0 + 李四3000 = 3000
- ✅ 总金额保持一致

### 2.3 隔离性（Isolation）

数据库系统提供的隔离机制，保证事务在**不受外部并发操作影响**的独立环境下运行。

**示例：**
- 张三给李四转账（事务A）
- 王五给李四转账（事务B）
- 两个事务互不影响

### 2.4 持久性（Durability）

事务一旦提交，对数据的改变就是**永久的**，即使系统故障也不会丢失。

**实现机制：**
- redo log（重做日志）
- binlog（二进制日志）

---

## 三、事务操作

### 3.1 数据准备

在进行事务操作演示之前，我们需要先创建测试数据。

```sql
-- 创建账户表
DROP TABLE IF EXISTS account;

CREATE TABLE account(
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',
    name VARCHAR(10) COMMENT '姓名',
    money DOUBLE(10,2) COMMENT '余额'
) COMMENT '账户表';

-- 插入测试数据
INSERT INTO account(name, money) VALUES ('张三', 2000), ('李四', 2000);
```

![image-20260111194432181](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194432181.png)

### 3.2 未控制事务

#### 3.2.1 测试正常情况

**说明**：默认情况下，MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。

```sql
-- 1. 查询张三余额
SELECT * FROM account WHERE name = '张三';

-- 2. 张三的余额减少1000
UPDATE account SET money = money - 1000 WHERE name = '张三';

-- 3. 李四的余额增加1000
UPDATE account SET money = money + 1000 WHERE name = '李四';
```

**结果**：测试完毕之后检查数据的状态，可以看到数据操作前后是一致的。张三的余额变为1000，李四的余额变为3000。

#### 3.2.2 测试异常情况

```sql
-- 1. 查询张三余额
SELECT * FROM account WHERE name = '张三';

-- 2. 张三的余额减少1000
UPDATE account SET money = money - 1000 WHERE name = '张三';

出错了....  -- 这一步不符合SQL语法，执行就会报错

-- 3. 李四的余额增加1000
UPDATE account SET money = money + 1000 WHERE name = '李四';
```

**问题**：我们把数据都恢复到2000，然后再次一次性执行上述的SQL语句（出错了....这句话不符合SQL语法，执行就会报错），检查最终的数据情况，发现数据在操作前后不一致了。

- ❌ 张三的余额减少了1000（因为第2步执行成功）
- ❌ 李四的余额没有增加（因为第3步没有执行）
- ❌ 钱凭空消失了！

![image-20260111194509427](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194509427.png)

**解决方案**：需要通过事务来控制，我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。

### 3.3 查看事务提交方式

```sql
-- 查看自动提交设置
SELECT @@autocommit;
-- 1表示自动提交（默认）
-- 0表示手动提交
```

### 3.4 方式一：控制自动提交

**步骤：**

1. 查看/设置事务提交方式

```sql
-- 查看当前设置
SELECT @@autocommit;  -- 默认为1

-- 设置为手动提交
SET @@autocommit = 0;
```

2. 执行SQL操作

```sql
-- 执行SQL操作（此时不会自动提交）
UPDATE account SET money = money - 1000 WHERE name = '张三';
UPDATE account SET money = money + 1000 WHERE name = '李四';
```

3. 提交事务

```sql
COMMIT;
```

4. 回滚事务（如果需要）

```sql
ROLLBACK;
```

**完整示例：**

```sql
-- 查看当前设置
SELECT @@autocommit;

-- 设置为手动提交
SET @@autocommit = 0;

-- 执行SQL操作
UPDATE account SET money = money - 1000 WHERE name = '张三';
UPDATE account SET money = money + 1000 WHERE name = '李四';

-- 提交事务
COMMIT;

-- 或回滚事务
ROLLBACK;

-- 恢复自动提交（操作完成后）
SET @@autocommit = 1;
```

⚠️ **注意**：上述的这种方式，我们是修改了事务的自动提交行为，把默认的自动提交修改为了手动提交，此时我们执行的DML语句都不会提交，需要手动的执行commit进行提交。修改`@@autocommit`会影响当前会话的所有后续操作。

### 3.5 方式二：手动开启事务（推荐）

**步骤：**

1. 开启事务

```sql
START TRANSACTION;
-- 或
BEGIN;
```

2. 执行SQL操作

```sql
UPDATE account SET money = money - 1000 WHERE name = '张三';
UPDATE account SET money = money + 1000 WHERE name = '李四';
```

3. 提交事务

```sql
COMMIT;
```

4. 回滚事务（如果需要）

```sql
ROLLBACK;
```

### 3.6 转账完整示例

使用方式二（手动开启事务）实现转账业务：

```sql
-- 开启事务
START TRANSACTION;

-- 1. 查询张三余额
SELECT * FROM account WHERE name = '张三';

-- 2. 张三的余额减少1000
UPDATE account SET money = money - 1000 WHERE name = '张三';

-- 3. 李四的余额增加1000
UPDATE account SET money = money + 1000 WHERE name = '李四';

-- 如果正常执行完毕, 则提交事务
COMMIT;

-- 如果执行过程中报错, 则回滚事务
-- ROLLBACK;
```

**结果验证：**

```sql
-- 验证结果
SELECT * FROM account;
-- 张三：1000，李四：3000
```

### 3.7 回滚示例

```sql
-- 开启事务
START TRANSACTION;

-- 执行操作
UPDATE account SET money = money - 1000 WHERE name = '张三';

-- 发现问题，回滚
ROLLBACK;

-- 数据恢复到事务开始前的状态
SELECT * FROM account;
-- 张三：2000，李四：2000（数据恢复）
```

---

## 四、事务隔离级别

### 4.1 为什么需要隔离级别？

多个事务并发执行时，如果不加控制，可能出现数据不一致的问题。

### 4.2 四种隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| **READ UNCOMMITTED**<br>读未提交 | ✅ 可能 | ✅ 可能 | ✅ 可能 |
| **READ COMMITTED**<br>读已提交 | ❌ 不可能 | ✅ 可能 | ✅ 可能 |
| **REPEATABLE READ**<br>可重复读（默认） | ❌ 不可能 | ❌ 不可能 | ✅ 可能 |
| **SERIALIZABLE**<br>串行化 | ❌ 不可能 | ❌ 不可能 | ❌ 不可能 |

**注意**：事务隔离级别越高，数据越安全，但是性能越低。

**说明**：隔离级别越高，数据一致性越好，但并发性能越差。

### 4.3 查看和设置隔离级别

**1). 查看事务隔离级别**

```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;
```

**2). 设置事务隔离级别**

```sql
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { 
    READ UNCOMMITTED | 
    READ COMMITTED | 
    REPEATABLE READ | 
    SERIALIZABLE 
}
```

```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 设置会话隔离级别（只影响当前会话）
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 设置全局隔离级别（影响所有新会话）
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

## 五、并发问题

### 5.1 脏读（Dirty Read）

**定义**：一个事务读到另外一个事务还没有提交的数据。

![image-20260111194621344](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194621344.png)

**说明**：比如B读取到了A未提交的数据。如果A事务回滚，B读到的数据就是无效的脏数据。

**演示：**

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | `START TRANSACTION;` | |
| T2 | `UPDATE account SET balance = 1000 WHERE id = 1;` | |
| T3 | | `START TRANSACTION;` |
| T4 | | `SELECT balance FROM account WHERE id = 1;`<br>**读到1000（脏数据）** |
| T5 | `ROLLBACK;` | |
| T6 | | **数据实际是2000，读到的1000是脏数据！** |

**解决**：设置隔离级别为 READ COMMITTED 或更高。

### 5.2 不可重复读（Non-Repeatable Read）

**定义**：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。

![image-20260111194629022](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194629022.png)

**说明**：事务A两次读取同一条记录，但是读取到的数据却是不一样的。这是因为其他事务修改并提交了数据。

**演示：**

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | `START TRANSACTION;` | |
| T2 | `SELECT balance FROM account WHERE id = 1;`<br>**读到2000** | |
| T3 | | `START TRANSACTION;` |
| T4 | | `UPDATE account SET balance = 1000 WHERE id = 1;` |
| T5 | | `COMMIT;` |
| T6 | `SELECT balance FROM account WHERE id = 1;`<br>**读到1000（不一致）** | |

**问题**：同一事务内，两次查询结果不同。

**解决**：设置隔离级别为 REPEATABLE READ 或更高。

### 5.3 幻读（Phantom Read）

**定义**：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 "幻影"。

![image-20260111194638561](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111194638561.png)

**说明**：一个事务内多次查询，后续查询发现了之前没有的记录。这是因为其他事务插入了新数据并提交了。

**演示：**

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | `START TRANSACTION;` | |
| T2 | `SELECT * FROM account WHERE balance > 1000;`<br>**查到2条** | |
| T3 | | `START TRANSACTION;` |
| T4 | | `INSERT INTO account VALUES (3, '王五', 1500);` |
| T5 | | `COMMIT;` |
| T6 | `SELECT * FROM account WHERE balance > 1000;`<br>**查到3条（多了一条）** | |

**问题**：像看到了"幻影"，突然多出了记录。

**解决**：设置隔离级别为 SERIALIZABLE。

### 5.4 并发问题对比

| 问题 | 发生原因 | 影响 |
|------|---------|------|
| **脏读** | 读到未提交的数据 | 读到的数据可能被回滚 |
| **不可重复读** | 读到已提交的修改 | 同一条记录多次读取不一致 |
| **幻读** | 读到已提交的插入 | 记录数量变化 |

---

## 六、实战案例

### 案例1：转账业务

```sql
-- 创建存储过程实现转账
DELIMITER $$

CREATE PROCEDURE transfer(
    IN from_account VARCHAR(50),
    IN to_account VARCHAR(50),
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE from_balance DECIMAL(10,2);
    
    -- 声明异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT '转账失败，已回滚' AS message;
    END;
    
    -- 开启事务
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO from_balance 
    FROM account 
    WHERE name = from_account;
    
    IF from_balance < amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
    END IF;
    
    -- 转出
    UPDATE account 
    SET balance = balance - amount 
    WHERE name = from_account;
    
    -- 转入
    UPDATE account 
    SET balance = balance + amount 
    WHERE name = to_account;
    
    -- 提交事务
    COMMIT;
    SELECT '转账成功' AS message;
END$$

DELIMITER ;

-- 调用存储过程
CALL transfer('张三', '李四', 500);
```

### 案例2：秒杀场景

```sql
-- 商品表
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    stock INT NOT NULL,
    sales INT DEFAULT 0
);

-- 订单表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT,
    user_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 秒杀逻辑
START TRANSACTION;

-- 1. 检查库存
SELECT stock FROM products WHERE id = 1 FOR UPDATE;  -- 加锁

-- 2. 库存充足，扣减库存
UPDATE products 
SET stock = stock - 1, sales = sales + 1 
WHERE id = 1 AND stock > 0;

-- 3. 创建订单
INSERT INTO orders (product_id, user_id) VALUES (1, 100);

-- 4. 提交事务
COMMIT;
```

### 案例3：测试事务隔离级别

```sql
-- 会话1：设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

START TRANSACTION;
SELECT * FROM account WHERE id = 1;

-- 会话2：修改数据但不提交
START TRANSACTION;
UPDATE account SET balance = 5000 WHERE id = 1;

-- 回到会话1：再次查询
SELECT * FROM account WHERE id = 1;  
-- 读未提交级别：会读到5000（脏读）
-- 读已提交级别：仍读到原值

-- 会话2：提交
COMMIT;

-- 会话1：再次查询
SELECT * FROM account WHERE id = 1;
-- 现在都能读到5000
```

---

## 七、本章总结

### 核心要点

1. **事务定义**：一组操作的集合，要么全成功，要么全失败
2. **ACID特性**：原子性、一致性、隔离性、持久性
3. **事务操作**：START TRANSACTION、COMMIT、ROLLBACK
4. **隔离级别**：读未提交、读已提交、可重复读、串行化
5. **并发问题**：脏读、不可重复读、幻读

### 最佳实践

1. ✅ **使用事务保护关键业务**（转账、订单、库存）
2. ✅ **尽量缩短事务时间**，避免长事务
3. ✅ **选择合适的隔离级别**（默认REPEATABLE READ通常够用）
4. ✅ **注意死锁问题**，合理设计事务逻辑
5. ✅ **使用异常处理**，确保异常时能回滚

### 隔离级别选择

```
性能要求高，允许脏读？
└─ 读未提交（不推荐）

防止脏读？
└─ 读已提交（Oracle、PostgreSQL默认）

防止不可重复读？
└─ 可重复读（MySQL默认，推荐）

严格串行执行？
└─ 串行化（性能最差，很少用）
```

---

## 练习题

```sql
-- 1. 创建测试数据
CREATE TABLE wallet (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    balance DECIMAL(10,2) NOT NULL
);

INSERT INTO wallet VALUES (1, 101, 1000), (2, 102, 500);

-- 2. 实现转账（带异常处理）
START TRANSACTION;
UPDATE wallet SET balance = balance - 100 WHERE user_id = 101;
UPDATE wallet SET balance = balance + 100 WHERE user_id = 102;
COMMIT;

-- 3. 测试回滚
START TRANSACTION;
UPDATE wallet SET balance = balance - 100 WHERE user_id = 101;
-- 发现错误，回滚
ROLLBACK;

-- 4. 测试不同隔离级别的效果
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- 开启两个会话，观察脏读现象
```

---

**上一章：** [多表查询与连接](/tutorials/java-backend/mysql/第02章-进阶篇/03-多表查询与连接/)

**下一章：** [存储引擎](/tutorials/java-backend/mysql/第03章-高级篇/01-存储引擎/) →
