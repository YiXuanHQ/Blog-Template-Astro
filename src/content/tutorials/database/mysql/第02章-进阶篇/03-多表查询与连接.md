---
title: 多表查询与连接
prevChapter: "java-backend/mysql/第02章-进阶篇/02-约束与数据完整性"
nextChapter: "java-backend/mysql/第02章-进阶篇/04-事务管理"
parentChapter: "java-backend/mysql/README"
---
# 多表查询与连接

> 实际项目中，数据通常分布在多个表中。本章将学习如何通过连接和子查询获取多表关联数据，掌握多表查询是处理复杂业务需求的核心技能。

## ⚡ 快速参考

- **多表关系**：一对多（多对一）、多对多、一对一
- **内连接（INNER JOIN）**：只返回两表匹配的记录，最常用
- **外连接**：LEFT JOIN（左外连接，返回左表所有记录）、RIGHT JOIN（右外连接，返回右表所有记录）
- **自连接**：同一张表与自身连接，处理层级关系
- **联合查询**：UNION（去重）、UNION ALL（不去重），合并多个查询结果
- **子查询**：标量子查询（单个值）、列子查询（一列）、行子查询（一行）、表子查询（多行多列）
- **笛卡尔积**：多表查询时需要添加连接条件消除无效组合

## 📚 学习目标

1. 理解数据库中的多表关系类型（一对多、多对多、一对一）及其实现方式
2. 掌握内连接、外连接、自连接的语法和使用场景
3. 熟练使用LEFT JOIN、RIGHT JOIN进行外连接查询
4. 理解联合查询（UNION）的用法和注意事项
5. 掌握各种类型的子查询（标量、列、行、表子查询）
6. 能够根据业务需求选择合适的连接方式和查询方法
7. 理解笛卡尔积的概念，避免无效数据组合
8. 掌握多表查询的性能优化技巧

## 一、多表关系

### 1.1 多表关系概述

项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：

- **一对多（多对一）**
- **多对多**
- **一对一**

### 1.2 一对多（多对一）

**案例**：部门与员工的关系

**关系**：一个部门对应多个员工，一个员工对应一个部门

**实现**：在多的一方建立外键，指向一的一方的主键

![image-20260111192658810](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111192658810.png)

**示例：**

```sql
-- 部门表（一的一方）
CREATE TABLE dept (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL
);

-- 员工表（多的一方）
CREATE TABLE emp (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES dept(id)  -- 外键指向部门表
);
```

### 1.3 多对多

**案例**：学生与课程的关系

**关系**：一个学生可以选修多门课程，一门课程也可以供多个学生选择

**实现**：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

![image-20260111192721049](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111192721049.png)

**对应的SQL脚本：**

```sql
-- 学生表
CREATE TABLE student(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    no varchar(10) comment '学号'
) comment '学生表';

-- 插入学生数据
INSERT INTO student VALUES 
(null, '黛绮丝', '2000100101'),
(null, '谢逊', '2000100102'),
(null, '殷天正', '2000100103'),
(null, '韦一笑', '2000100104');

-- 课程表
CREATE TABLE course(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '课程名称'
) comment '课程表';

-- 插入课程数据
INSERT INTO course VALUES 
(null, 'Java'), 
(null, 'PHP'), 
(null, 'MySQL'), 
(null, 'Hadoop');

-- 学生课程中间表（多对多关系表）
CREATE TABLE student_course(
    id int auto_increment comment '主键' primary key,
    studentid int not null comment '学生ID',
    courseid int not null comment '课程ID',
    constraint fk_courseid foreign key (courseid) references course (id),
    constraint fk_studentid foreign key (studentid) references student (id)
) comment '学生课程中间表';

-- 插入选课数据
INSERT INTO student_course VALUES 
(null,1,1),
(null,1,2),
(null,1,3),
(null,2,2),
(null,2,3),
(null,3,4);
```

### 1.4 一对一

**案例**：用户与用户详情的关系

**关系**：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率

**实现**：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)

![image-20260111192744230](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111192744230.png)

**对应的SQL脚本：**

```sql
-- 用户基本信息表
CREATE TABLE tb_user(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    age int comment '年龄',
    gender char(1) comment '1: 男 , 2: 女',
    phone char(11) comment '手机号'
) comment '用户基本信息表';

-- 用户教育信息表
CREATE TABLE tb_user_edu(
    id int auto_increment primary key comment '主键ID',
    degree varchar(20) comment '学历',
    major varchar(50) comment '专业',
    primaryschool varchar(50) comment '小学',
    middleschool varchar(50) comment '中学',
    university varchar(50) comment '大学',
    userid int unique comment '用户ID',
    constraint fk_userid foreign key (userid) references tb_user(id)
) comment '用户教育信息表';

-- 插入用户数据
INSERT INTO tb_user(id, name, age, gender, phone) VALUES
(null,'黄渤',45,'1','18800001111'),
(null,'冰冰',35,'2','18800002222'),
(null,'码云',55,'1','18800008888'),
(null,'李彦宏',50,'1','18800009999');

-- 插入教育信息数据
INSERT INTO tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid) VALUES
(null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),
(null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),
(null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),
(null,'本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);
```

---

## 二、多表查询概述

### 2.1 为什么需要多表查询？

在数据库设计中，为避免数据冗余，我们将数据分散存储在多个表中。查询时需要关联这些表。

**多表查询**就是指从多张表中查询数据。

### 2.2 数据准备

**1). 删除之前 emp, dept表的测试数据**

```sql
-- 如果表已存在，先删除
DROP TABLE IF EXISTS emp;
DROP TABLE IF EXISTS dept;
```

**2). 执行如下脚本，创建emp表与dept表并插入测试数据**

```sql
-- 创建dept表，并插入数据
CREATE TABLE dept(
    id int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '部门名称'
) comment '部门表';

INSERT INTO dept (id, name) VALUES 
(1, '研发部'), 
(2, '市场部'),
(3, '财务部'), 
(4, '销售部'), 
(5, '总经办'), 
(6, '人事部');

-- 创建emp表，并插入数据
CREATE TABLE emp(
    id int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '姓名',
    age int comment '年龄',
    job varchar(20) comment '职位',
    salary int comment '薪资',
    entrydate date comment '入职时间',
    managerid int comment '直属领导ID',
    dept_id int comment '部门ID'
) comment '员工表';

-- 添加外键
ALTER TABLE emp 
ADD CONSTRAINT fk_emp_dept_id 
FOREIGN KEY (dept_id) REFERENCES dept(id);

-- 插入员工数据
INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id) VALUES
(1, '金庸', 66, '总裁', 20000, '2000-01-01', null, 5),
(2, '张无忌', 20, '项目经理', 12500, '2005-12-05', 1, 1),
(3, '杨逍', 33, '开发', 8400, '2000-11-03', 2, 1),
(4, '韦一笑', 48, '开发', 11000, '2002-02-05', 2, 1),
(5, '常遇春', 43, '开发', 10500, '2004-09-07', 3, 1),
(6, '小昭', 19, '程序员鼓励师', 6600, '2004-10-12', 2, 1),
(7, '灭绝', 60, '财务总监', 8500, '2002-09-12', 1, 3),
(8, '周芷若', 19, '会计', 48000, '2006-06-02', 7, 3),
(9, '丁敏君', 23, '出纳', 5250, '2009-05-13', 7, 3),
(10, '赵敏', 20, '市场部总监', 12500, '2004-10-12', 1, 2),
(11, '鹿杖客', 56, '职员', 3750, '2006-10-03', 10, 2),
(12, '鹤笔翁', 19, '职员', 3750, '2007-05-09', 10, 2),
(13, '方东白', 19, '职员', 5500, '2009-02-12', 10, 2),
(14, '张三丰', 88, '销售总监', 14000, '2004-10-12', 1, 4),
(15, '俞莲舟', 38, '销售', 4600, '2004-10-12', 14, 4),
(16, '宋远桥', 40, '销售', 4600, '2004-10-12', 14, 4),
(17, '陈友谅', 42, null, 2000, '2011-10-12', 1, null);
```

**数据说明：**
- dept表共6条记录
- emp表共17条记录

### 2.3 笛卡尔积

原来查询单表数据，执行的SQL形式为：

```sql
SELECT * FROM emp;
```

那么我们要执行多表查询，就只需要使用逗号分隔多张表即可：

```sql
SELECT * FROM emp, dept;
```

**执行结果分析：**

![image-20260111192939788](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111192939788.png)

此时，我们看到查询结果中包含了大量的结果集，总共102条记录（17×6=102），而这其实就是员工表emp所有的记录(17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为**笛卡尔积**。

**笛卡尔积**：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193039297.png" alt="image-20260111193039297" style="zoom:50%;" />

而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193046550.png" alt="image-20260111193046550" style="zoom:50%;" />

![image-20260111193100686](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193100686.png)

**在SQL语句中，如何来去除无效的笛卡尔积呢？**

我们可以给多表查询加上连接查询的条件即可：

```sql
-- 添加连接条件，消除无效的笛卡尔积
SELECT * FROM emp, dept WHERE emp.dept_id = dept.id;
```

**结果说明：**

![image-20260111193126274](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193126274.png)

而由于id为17的员工（陈友谅），没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。

### 2.4 多表查询分类

多表查询主要分为两大类：

**1. 连接查询**

- **内连接**：相当于查询A、B交集部分数据
- **外连接**：
  - **左外连接**：查询左表所有数据，以及两张表交集部分数据
  - **右外连接**：查询右表所有数据，以及两张表交集部分数据
- **自连接**：当前表与自身的连接查询，自连接必须使用表别名

**2. 子查询**

![image-20260111193204931](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193204931.png)

---

## 三、内连接

### 3.1 什么是内连接？

![image-20260111193219463](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193219463.png)

内连接查询的是两张表**交集部分的数据**（也就是绿色部分的数据）。

内连接（INNER JOIN）返回两个表中**匹配的记录**，不匹配的记录被过滤掉。

### 3.2 内连接语法

内连接的语法分为两种：**隐式内连接**、**显式内连接**。

**1). 隐式内连接**

```sql
SELECT 字段列表 FROM 表1, 表2 WHERE 连接条件;
```

**2). 显式内连接**

```sql
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;
-- INNER可以省略
SELECT 字段列表 FROM 表1 JOIN 表2 ON 连接条件;
```

### 3.3 案例演示

**案例A：查询每一个员工的姓名，及关联的部门的名称（隐式内连接实现）**

- **表结构**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
-- 隐式内连接：查询所有员工及其部门
SELECT emp.name, dept.name 
FROM emp, dept 
WHERE emp.dept_id = dept.id;
```

**表的别名：**

```sql
-- 方式一：使用AS关键字
SELECT e.name AS 员工姓名, d.name AS 部门名称
FROM emp AS e, dept AS d 
WHERE e.dept_id = d.id;

-- 方式二：直接使用别名（推荐）
SELECT e.name, d.name 
FROM emp e, dept d 
WHERE e.dept_id = d.id;
```

**注意事项：**

一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。

**案例B：查询每一个员工的姓名，及关联的部门的名称（显式内连接实现）**

- **表结构**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
-- 显式内连接：使用INNER JOIN
SELECT e.name, d.name 
FROM emp e 
INNER JOIN dept d ON e.dept_id = d.id;

-- 显式内连接：省略INNER（推荐）
SELECT e.name, d.name 
FROM emp e 
JOIN dept d ON e.dept_id = d.id;
```

### 3.4 更多示例

```sql
-- 使用表别名简化SQL
SELECT e.name AS 员工姓名, d.name AS 部门名称
FROM emp e, dept d 
WHERE e.dept_id = d.id;

-- 显式内连接
SELECT e.name, e.salary, d.name
FROM emp e 
INNER JOIN dept d ON e.dept_id = d.id;

-- 多条件连接
SELECT e.name, d.name
FROM emp e 
JOIN dept d ON e.dept_id = d.id 
WHERE e.salary > 8000;
```

### 3.5 多表连接

```sql
-- 三表连接：员工、部门、项目
SELECT e.name, d.name, p.project_name
FROM emp e
JOIN dept d ON e.dept_id = d.id
JOIN projects p ON p.dept_id = d.id;
```

---

## 四、外连接

### 4.1 什么是外连接？

![image-20260111193246731](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193246731.png)

外连接分为两种，分别是：**左外连接**和**右外连接**。

外连接不仅返回匹配的记录，还返回不匹配的记录。

- **左外连接（LEFT JOIN）**：返回左表所有记录 + 右表匹配的记录
- **右外连接（RIGHT JOIN）**：返回右表所有记录 + 左表匹配的记录

### 4.2 左外连接

**语法：**

```sql
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 ...;
```

**特点：**

左外连接相当于查询表1（左表）的所有数据，当然也包含表1和表2交集部分的数据。

**案例A：查询emp表的所有数据，和对应的部门信息**

由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。

- **表结构**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
-- 查询所有员工及其部门（包括没有部门的员工）
SELECT e.*, d.name AS dept_name
FROM emp e 
LEFT OUTER JOIN dept d ON e.dept_id = d.id;

-- 或者省略OUTER
SELECT e.*, d.name AS dept_name
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id;
```

**结果说明：**

结果包含所有员工，即使没有部门的员工（如陈友谅，dept_id为NULL）也会显示，部门名称字段为NULL。

**查询没有分配部门的员工：**

```sql
SELECT e.*
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id
WHERE d.id IS NULL;
```

### 4.3 右外连接

**语法：**

```sql
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...;
```

**特点：**

右外连接相当于查询表2（右表）的所有数据，当然也包含表1和表2交集部分的数据。

**案例B：查询dept表的所有数据，和对应的员工信息（右外连接）**

由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。

- **表结构**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
-- 右外连接：查询所有部门及其员工（包括没有员工的部门）
SELECT d.*, e.* 
FROM emp e 
RIGHT OUTER JOIN dept d ON e.dept_id = d.id;

-- 或者省略OUTER
SELECT d.*, e.* 
FROM emp e 
RIGHT JOIN dept d ON e.dept_id = d.id;
```

**注意事项：**

左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。

```sql
-- 右外连接
SELECT d.*, e.* 
FROM emp e 
RIGHT JOIN dept d ON e.dept_id = d.id;

-- 等价于左外连接（调换表的位置）
SELECT d.*, e.* 
FROM dept d 
LEFT JOIN emp e ON d.id = e.dept_id;
```

### 4.4 内连接 vs 外连接

| 类型 | 说明 | 不匹配记录 |
|------|------|-----------|
| **内连接** | 只返回匹配的记录 | 过滤掉 |
| **左外连接** | 返回左表所有记录 | 右表字段为NULL |
| **右外连接** | 返回右表所有记录 | 左表字段为NULL |

**选择建议：**
- ✅ 需要所有记录 → 外连接
- ✅ 只要匹配记录 → 内连接
- ✅ 左外连接最常用

---

## 五、自连接

### 4.1 什么是自连接？

表与自己进行连接，常用于处理**层级关系**。

### 4.2 应用场景

```sql
-- 员工表（包含上级领导ID）
CREATE TABLE employee (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT
);

INSERT INTO employee VALUES
(1, '张总', NULL),
(2, '李经理', 1),
(3, '王主管', 2),
(4, '小明', 3),
(5, '小红', 3);
```

### 4.3 自连接查询

```sql
-- 查询每个员工及其直属领导
SELECT 
    e.name AS 员工,
    m.name AS 领导
FROM employee e
LEFT JOIN employee m ON e.manager_id = m.id;

-- 结果
+--------+--------+
| 员工   | 领导   |
+--------+--------+
| 张总   | NULL   |
| 李经理 | 张总   |
| 王主管 | 李经理 |
| 小明   | 王主管 |
| 小红   | 王主管 |
+--------+--------+

-- 查询没有领导的员工（最高领导）
SELECT e.name
FROM employee e
WHERE e.manager_id IS NULL;
```

---

## 六、联合查询

### 6.1 什么是联合查询？

对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。

**语法：**

```sql
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B ....;
```

### 6.2 UNION vs UNION ALL

| 类型 | 说明 |
|------|------|
| `UNION` | 合并结果并**去重** |
| `UNION ALL` | 合并结果**不去重**（性能更好） |

**union all**会将全部的数据直接合并在一起，**union**会对合并之后的数据去重。

### 6.3 案例演示

**案例A：将薪资低于5000的员工，和年龄大于50岁的员工全部查询出来**

当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符or连接即可。那这里呢，我们也可以通过union/union all来联合查询。

```sql
-- 方式一：使用OR（多条件查询）
SELECT * FROM emp WHERE salary < 5000 OR age > 50;

-- 方式二：使用UNION ALL（联合查询，不去重）
SELECT * FROM emp WHERE salary < 5000
UNION ALL
SELECT * FROM emp WHERE age > 50;

-- 方式三：使用UNION（联合查询，去重）
SELECT * FROM emp WHERE salary < 5000
UNION
SELECT * FROM emp WHERE age > 50;
```

**结果说明：**

![image-20260111193334266](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193334266.png)

- **union all**查询出来的结果，仅仅进行简单的合并，并未去重
- **union**联合查询，会对查询出来的结果进行去重处理

### 6.4 注意事项

⚠️ **要求**：

![image-20260111193427728](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260111193427728.png)

1. 对于联合查询的多张表的**列数必须保持一致**，字段类型也需要保持一致
2. 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错

```sql
-- 正确示例：列数相同
SELECT id, name FROM emp
UNION
SELECT id, name FROM manager
ORDER BY id;

-- 错误示例：列数不同
SELECT id, name FROM emp
UNION
SELECT id FROM manager;  -- ❌ 列数不匹配，会报错
```

3. 只能有一个ORDER BY（放在最后）

```sql
-- 正确：ORDER BY放在最后
SELECT * FROM emp WHERE age < 30
UNION
SELECT * FROM emp WHERE salary > 10000
ORDER BY id;
```

---

## 七、子查询

### 7.1 子查询概述

**1). 概念**

SQL语句中嵌套SELECT语句，称为嵌套查询，又称**子查询**。

```sql
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
```

子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。

**2). 分类**

**根据子查询结果不同，分为：**

- **A. 标量子查询**（子查询结果为单个值）
- **B. 列子查询**（子查询结果为一列）
- **C. 行子查询**（子查询结果为一行）
- **D. 表子查询**（子查询结果为多行多列）

**根据子查询位置，分为：**

- **A. WHERE之后**
- **B. FROM之后**
- **C. SELECT之后**

### 7.2 子查询分类总览

根据返回结果分类：

| 类型 | 说明 | 示例 |
|------|------|------|
| **标量子查询** | 返回单个值 | `SELECT ... WHERE age > (子查询)` |
| **列子查询** | 返回一列多行 | `SELECT ... WHERE id IN (子查询)` |
| **行子查询** | 返回一行多列 | `SELECT ... WHERE (a,b) = (子查询)` |
| **表子查询** | 返回多行多列 | `SELECT ... FROM (子查询)` |

### 7.3 标量子查询

子查询返回的结果是**单个值**（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。

**常用的操作符**：`=`, `<>`, `>`, `>=`, `<`, `<=`

**案例A：查询"销售部"的所有员工信息**

完成这个需求时，我们可以将需求分解为两步：

①. 查询"销售部"部门ID

```sql
SELECT id FROM dept WHERE name = '销售部';
```

②. 根据"销售部"部门ID，查询员工信息

```sql
SELECT * FROM emp 
WHERE dept_id = (SELECT id FROM dept WHERE name = '销售部');
```

**案例B：查询在"方东白"入职之后的员工信息**

完成这个需求时，我们可以将需求分解为两步：

①. 查询方东白的入职日期

```sql
SELECT entrydate FROM emp WHERE name = '方东白';
```

②. 查询指定入职日期之后入职的员工信息

```sql
SELECT * FROM emp 
WHERE entrydate > (SELECT entrydate FROM emp WHERE name = '方东白');
```

### 7.4 更多标量子查询示例

```sql
-- 1. 查询工资高于平均工资的员工
SELECT * FROM emp 
WHERE salary > (SELECT AVG(salary) FROM emp);

-- 2. 查询"销售部"的所有员工
SELECT * FROM emp 
WHERE dept_id = (SELECT id FROM dept WHERE name = '销售部');

-- 3. 查询在"张三"入职之后的员工
SELECT * FROM emp 
WHERE entrydate > (SELECT entrydate FROM emp WHERE name = '张三');
```

### 7.5 列子查询

子查询返回的结果是**一列**（可以是多行），这种子查询称为列子查询。

**常用的操作符：**

| 操作符 | 描述 |
|--------|------|
| `IN` | 在指定的集合范围之内，多选一 |
| `NOT IN` | 不在指定的集合范围之内 |
| `ANY` | 子查询返回列表中，有任意一个满足即可 |
| `SOME` | 与ANY等同，使用SOME的地方都可以使用ANY |
| `ALL` | 子查询返回列表的所有值都必须满足 |

**案例A：查询"销售部"和"市场部"的所有员工信息**

分解为以下两步：

①. 查询"销售部"和"市场部"的部门ID

```sql
SELECT id FROM dept WHERE name = '销售部' OR name = '市场部';
```

②. 根据部门ID，查询员工信息

```sql
SELECT * FROM emp 
WHERE dept_id IN (
    SELECT id FROM dept 
    WHERE name = '销售部' OR name = '市场部'
);
```

**案例B：查询比财务部所有人工资都高的员工信息**

分解为以下两步：

①. 查询所有财务部人员工资

```sql
SELECT id FROM dept WHERE name = '财务部';
SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = '财务部');
```

②. 比财务部所有人工资都高的员工信息

```sql
SELECT * FROM emp 
WHERE salary > ALL (
    SELECT salary FROM emp 
    WHERE dept_id = (SELECT id FROM dept WHERE name = '财务部')
);
```

**案例C：查询比研发部其中任意一人工资高的员工信息**

分解为以下两步：

①. 查询研发部所有人工资

```sql
SELECT salary FROM emp 
WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部');
```

②. 比研发部其中任意一人工资高的员工信息

```sql
SELECT * FROM emp 
WHERE salary > ANY (
    SELECT salary FROM emp 
    WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部')
);
```

### 7.6 更多列子查询示例

```sql
-- 1. 查询"销售部"和"市场部"的所有员工
SELECT * FROM emp 
WHERE dept_id IN (
    SELECT id FROM dept 
    WHERE name IN ('销售部', '市场部')
);

-- 2. 查询工资比财务部所有人都高的员工
SELECT * FROM emp 
WHERE salary > ALL (
    SELECT salary FROM emp 
    WHERE dept_id = (SELECT id FROM dept WHERE name = '财务部')
);

-- 3. 查询工资比研发部任意一人高的员工
SELECT * FROM emp 
WHERE salary > ANY (
    SELECT salary FROM emp 
    WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部')
);
```

### 7.7 行子查询

子查询返回的结果是**一行**（可以是多列），这种子查询称为行子查询。

**常用的操作符**：`=`, `<>`, `IN`, `NOT IN`

**案例A：查询与"张无忌"的薪资及直属领导相同的员工信息**

这个需求同样可以拆解为两步进行：

①. 查询"张无忌"的薪资及直属领导

```sql
SELECT salary, managerid FROM emp WHERE name = '张无忌';
```

②. 查询与"张无忌"的薪资及直属领导相同的员工信息

```sql
SELECT * FROM emp 
WHERE (salary, managerid) = (
    SELECT salary, managerid FROM emp WHERE name = '张无忌'
);
```

### 7.8 更多行子查询示例

```sql
-- 查询与"张三"的工资和部门都相同的员工
SELECT * FROM emp 
WHERE (salary, dept_id) = (
    SELECT salary, dept_id FROM emp WHERE name = '张三'
);

-- 查询与"李四"的年龄和工资都相同的员工
SELECT * FROM emp 
WHERE (age, salary) = (
    SELECT age, salary FROM emp WHERE name = '李四'
);
```

### 7.9 表子查询

子查询返回的结果是**多行多列**，这种子查询称为表子查询。

**常用的操作符**：`IN`

**案例A：查询与"鹿杖客"，"宋远桥"的职位和薪资相同的员工信息**

分解为两步执行：

①. 查询"鹿杖客"，"宋远桥"的职位和薪资

```sql
SELECT job, salary FROM emp WHERE name = '鹿杖客' OR name = '宋远桥';
```

②. 查询与"鹿杖客"，"宋远桥"的职位和薪资相同的员工信息

```sql
SELECT * FROM emp 
WHERE (job, salary) IN (
    SELECT job, salary FROM emp 
    WHERE name = '鹿杖客' OR name = '宋远桥'
);
```

**案例B：查询入职日期是"2006-01-01"之后的员工信息，及其部门信息**

分解为两步执行：

①. 入职日期是"2006-01-01"之后的员工信息

```sql
SELECT * FROM emp WHERE entrydate > '2006-01-01';
```

②. 查询这部分员工，对应的部门信息

```sql
SELECT e.*, d.* 
FROM (
    SELECT * FROM emp WHERE entrydate > '2006-01-01'
) e 
LEFT JOIN dept d ON e.dept_id = d.id;
```

### 7.10 更多表子查询示例

```sql
-- 1. 查询入职日期在"2020-01-01"之后的员工及其部门
SELECT e.*, d.name
FROM (
    SELECT * FROM emp WHERE entrydate > '2020-01-01'
) e
LEFT JOIN dept d ON e.dept_id = d.id;

-- 2. 查询工资排名前5的员工
SELECT * FROM (
    SELECT * FROM emp ORDER BY salary DESC LIMIT 5
) top5;

-- 3. 部门统计后再查询
SELECT d.name, stat.emp_count, stat.avg_salary
FROM dept d
JOIN (
    SELECT 
        dept_id, 
        COUNT(*) AS emp_count,
        AVG(salary) AS avg_salary
    FROM emp
    GROUP BY dept_id
) stat ON d.id = stat.dept_id;
```

---

## 八、多表查询案例

### 8.1 数据环境准备

在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的需求。这里主要涉及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表。

**创建薪资等级表：**

```sql
-- 创建薪资等级表
CREATE TABLE salgrade(
    grade int,
    losal int,
    hisal int
) comment '薪资等级表';

-- 插入薪资等级数据
INSERT INTO salgrade VALUES (1,0,3000);
INSERT INTO salgrade VALUES (2,3001,5000);
INSERT INTO salgrade VALUES (3,5001,8000);
INSERT INTO salgrade VALUES (4,8001,10000);
INSERT INTO salgrade VALUES (5,10001,15000);
INSERT INTO salgrade VALUES (6,15001,20000);
INSERT INTO salgrade VALUES (7,20001,25000);
INSERT INTO salgrade VALUES (8,25001,30000);
```

### 8.2 案例需求

**1). 查询员工的姓名、年龄、职位、部门信息（隐式内连接）**

- **表**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
SELECT e.name, e.age, e.job, d.name 
FROM emp e, dept d 
WHERE e.dept_id = d.id;
```

**2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）**

- **表**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
SELECT e.name, e.age, e.job, d.name 
FROM emp e 
INNER JOIN dept d ON e.dept_id = d.id 
WHERE e.age < 30;
```

**3). 查询拥有员工的部门ID、部门名称**

- **表**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
SELECT DISTINCT d.id, d.name 
FROM emp e, dept d 
WHERE e.dept_id = d.id;
```

**4). 查询所有年龄大于40岁的员工，及其归属的部门名称；如果员工没有分配部门，也需要展示出来（外连接）**

- **表**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
SELECT e.*, d.name 
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id 
WHERE e.age > 40;
```

**5). 查询所有员工的工资等级**

- **表**：emp, salgrade
- **连接条件**：emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal

```sql
-- 方式一：使用比较运算符
SELECT e.*, s.grade, s.losal, s.hisal 
FROM emp e, salgrade s 
WHERE e.salary >= s.losal AND e.salary <= s.hisal;

-- 方式二：使用BETWEEN（推荐）
SELECT e.*, s.grade, s.losal, s.hisal 
FROM emp e, salgrade s 
WHERE e.salary BETWEEN s.losal AND s.hisal;
```

**6). 查询"研发部"所有员工的信息及工资等级**

- **表**：emp, salgrade, dept
- **连接条件**：emp.salary between salgrade.losal and salgrade.hisal, emp.dept_id = dept.id
- **查询条件**：dept.name = '研发部'

```sql
SELECT e.*, s.grade 
FROM emp e, dept d, salgrade s 
WHERE e.dept_id = d.id 
  AND (e.salary BETWEEN s.losal AND s.hisal) 
  AND d.name = '研发部';
```

**7). 查询"研发部"员工的平均工资**

- **表**：emp, dept
- **连接条件**：emp.dept_id = dept.id

```sql
SELECT AVG(e.salary) 
FROM emp e, dept d 
WHERE e.dept_id = d.id AND d.name = '研发部';
```

**8). 查询工资比"灭绝"高的员工信息**

分解为以下两步：

①. 查询"灭绝"的薪资

```sql
SELECT salary FROM emp WHERE name = '灭绝';
```

②. 查询比她工资高的员工数据

```sql
SELECT * FROM emp 
WHERE salary > (SELECT salary FROM emp WHERE name = '灭绝');
```

**9). 查询比平均薪资高的员工信息**

分解为以下两步：

①. 查询员工的平均薪资

```sql
SELECT AVG(salary) FROM emp;
```

②. 查询比平均薪资高的员工信息

```sql
SELECT * FROM emp 
WHERE salary > (SELECT AVG(salary) FROM emp);
```

**10). 查询低于本部门平均工资的员工信息**

分解为以下两步：

①. 查询指定部门平均薪资

```sql
SELECT AVG(e1.salary) FROM emp e1 WHERE e1.dept_id = 1;
SELECT AVG(e1.salary) FROM emp e1 WHERE e1.dept_id = 2;
-- ... 其他部门
```

②. 查询低于本部门平均工资的员工信息

```sql
SELECT * FROM emp e2 
WHERE e2.salary < (
    SELECT AVG(e1.salary) 
    FROM emp e1 
    WHERE e1.dept_id = e2.dept_id
);
```

**11). 查询所有的部门信息，并统计部门的员工人数**

```sql
SELECT 
    d.id,
    d.name,
    COUNT(e.id) AS emp_count
FROM dept d
LEFT JOIN emp e ON d.id = e.dept_id
GROUP BY d.id, d.name;
```

**12). 查询所有学生的选课情况，展示出学生名称，学号，课程名称**

- **表**：student, course, student_course
- **连接条件**：student.id = student_course.studentid, course.id = student_course.courseid

```sql
SELECT 
    s.name AS 学生名称,
    s.no AS 学号,
    c.name AS 课程名称
FROM student s
JOIN student_course sc ON s.id = sc.studentid
JOIN course c ON c.id = sc.courseid;
```

**备注**：以上需求的实现方式可能会很多，SQL写法也有很多，只要能满足我们的需求，查询出符合条件的记录即可。

---

## 九、综合案例

### 案例1：员工工资分析

```sql
-- 查询每个部门的员工数、平均工资、最高工资
SELECT 
    d.name AS 部门,
    COUNT(e.id) AS 员工数,
    ROUND(AVG(e.salary), 2) AS 平均工资,
    MAX(e.salary) AS 最高工资
FROM dept d
LEFT JOIN emp e ON d.id = e.dept_id
GROUP BY d.id, d.name
ORDER BY 平均工资 DESC;
```

### 案例2：找出每个部门工资最高的员工

```sql
-- 方法一：子查询
SELECT e.*, d.name AS dept_name
FROM emp e
JOIN dept d ON e.dept_id = d.id
WHERE e.salary = (
    SELECT MAX(salary) 
    FROM emp 
    WHERE dept_id = e.dept_id
);

-- 方法二：窗口函数（MySQL 8.0+）
SELECT name, dept_name, salary
FROM (
    SELECT 
        e.name,
        d.name AS dept_name,
        e.salary,
        RANK() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) AS rn
    FROM emp e
    JOIN dept d ON e.dept_id = d.id
) ranked
WHERE rn = 1;
```

### 案例3：员工层级查询

```sql
-- 查询完整的管理层级
WITH RECURSIVE emp_hierarchy AS (
    -- 起始：最高领导
    SELECT id, name, manager_id, 1 AS level, name AS path
    FROM employee
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归：下级员工
    SELECT e.id, e.name, e.manager_id, h.level + 1, 
           CONCAT(h.path, ' -> ', e.name)
    FROM employee e
    JOIN emp_hierarchy h ON e.manager_id = h.id
)
SELECT * FROM emp_hierarchy ORDER BY level, id;
```

---

## 十、本章总结

### 核心要点

1. **内连接**：只返回匹配的记录（最常用）
2. **外连接**：返回所有记录（左外连接最常用）
3. **自连接**：处理层级关系
4. **联合查询**：合并多个查询结果
5. **子查询**：嵌套查询，分为标量、列、行、表子查询

### 连接类型选择

```
需要所有记录？
├─ 是 → 外连接（LEFT/RIGHT JOIN）
└─ 否 → 内连接（INNER JOIN）

同一张表关联？
└─ 是 → 自连接

合并多个查询结果？
└─ 是 → UNION / UNION ALL
```

### 性能优化建议

- ✅ 优先使用JOIN而不是子查询
- ✅ 注意添加索引到连接字段
- ✅ 避免SELECT *，明确指定字段
- ✅ 大数据量时注意笛卡尔积

---

## 练习题

```sql
-- 1. 查询所有员工及其部门（包括无部门员工）
SELECT e.*, d.name 
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id;

-- 2. 查询工资高于本部门平均工资的员工
SELECT e.*
FROM emp e
WHERE e.salary > (
    SELECT AVG(salary) 
    FROM emp 
    WHERE dept_id = e.dept_id
);

-- 3. 查询没有员工的部门
SELECT d.*
FROM dept d
LEFT JOIN emp e ON d.id = e.dept_id
WHERE e.id IS NULL;

-- 4. 查询每个部门工资排名前3的员工
SELECT dept_name, name, salary, rn
FROM (
    SELECT 
        d.name AS dept_name,
        e.name,
        e.salary,
        ROW_NUMBER() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) AS rn
    FROM emp e
    JOIN dept d ON e.dept_id = d.id
) ranked
WHERE rn <= 3;
```

---

**上一章：** [约束与数据完整性](/tutorials/java-backend/mysql/第02章-进阶篇/02-约束与数据完整性/)

**下一章：** [事务管理](/tutorials/java-backend/mysql/第02章-进阶篇/04-事务管理/) →
