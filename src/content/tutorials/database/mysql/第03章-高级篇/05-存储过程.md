---
title: 存储过程与函数
prevChapter: "java-backend/mysql/第03章-高级篇/04-视图"
nextChapter: "java-backend/mysql/第03章-高级篇/06-触发器"
parentChapter: "java-backend/mysql/README"
---
# 存储过程与函数

> 存储过程是预编译的SQL语句集合，提高性能和代码复用性。本章学习存储过程的创建和使用，掌握存储过程是提高数据库开发效率的重要技术。

## ⚡ 快速参考

- **存储过程定义**：预编译的SQL语句集合，存储在数据库中，可重复调用
- **存储过程特点**：预编译（性能好）、减少网络传输、支持参数、支持变量和流程控制
- **存储过程操作**：CREATE PROCEDURE、CALL、DROP PROCEDURE、SHOW PROCEDURE STATUS
- **参数类型**：IN（输入）、OUT（输出）、INOUT（输入输出）
- **流程控制**：IF、CASE、WHILE、LOOP、REPEAT、LEAVE、ITERATE
- **存储函数**：有返回值的存储过程，使用RETURNS和RETURN
- **优势**：提高性能、代码复用、减少网络开销、业务逻辑封装

## 📚 学习目标

1. 理解存储过程的概念和特点，掌握存储过程与普通SQL的区别
2. 掌握存储过程的创建、调用和删除操作
3. 理解存储过程的参数类型（IN、OUT、INOUT）及使用方法
4. 掌握存储过程中的变量定义和使用
5. 理解存储过程的流程控制语句（IF、CASE、WHILE等）
6. 掌握存储函数的创建和使用
7. 理解存储过程的优缺点，能够合理使用存储过程
8. 掌握存储过程在实际业务场景中的应用

## 一、存储过程概述

### 1.1 什么是存储过程？

**存储过程（Stored Procedure）** 是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。

存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。

![image-20260112100644749](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100644749.png)

**特点：**

- 📦 **封装，复用**：可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。
- 📥📤 **可以接收参数，也可以返回数据**：在存储过程中，可以传递参数，也可以接收返回值。
- 📈 **减少网络交互，效率提升**：如果涉及到多条SQL，每执行一次都是一次网络传输。而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。

### 1.2 存储过程 vs 普通SQL

| 特性 | 存储过程 | 普通SQL |
|------|---------|---------|
| 编译 | 预编译，只编译一次 | 每次执行都编译 |
| 网络传输 | 只传输调用命令 | 传输完整SQL |
| 复用性 | 高，可重复调用 | 需要重复编写 |
| 逻辑复杂度 | 支持复杂逻辑 | 有限 |
| 性能 | 较好 | 一般 |

### 1.3 实际工作中何时用存储过程？

**适合使用存储过程的场景：**

**场景1：复杂的业务逻辑（推荐）**
```sql
-- 例如：订单结算流程
-- 涉及：检查库存、创建订单、扣减库存、计算优惠、扣减余额、增加积分等
CALL p_create_order(user_id, product_id, quantity, @order_id, @result);
```
**为什么用**：封装复杂逻辑，减少应用层代码，减少网络往返次数。

**场景2：批量数据处理**
```sql
-- 例如：每日账单结算
CALL p_daily_settlement('2024-01-01');
-- 内部处理：统计当日订单、计算佣金、生成报表、发送通知
```
**为什么用**：一次性处理大量数据，减少网络传输，提高效率。

**场景3：定时任务（配合Event）**
```sql
-- 例如：自动关闭超时未支付订单
CALL p_close_timeout_orders();
-- 每隔5分钟执行一次
```
**为什么用**：适合放在数据库层定期执行，无需额外的调度服务。

**场景4：数据迁移和清洗**
```sql
-- 例如：历史数据归档
CALL p_archive_old_orders('2023-01-01');
-- 将旧订单迁移到历史表
```

**不适合使用存储过程的场景：**
- ❌ 简单的CRUD操作（增删改查）
- ❌ 需要频繁修改的业务逻辑（维护成本高）
- ❌ 跨数据库平台的应用（移植性差）
- ❌ 复杂的业务逻辑（应该放在应用层）

**现代开发趋势：**
- ⚠️ 微服务架构下，更推荐将逻辑放在应用层
- ✅ 但对于数据密集型操作，存储过程仍有优势
- ✅ 金融、电商等对性能要求高的场景，存储过程很常用

### 1.4 基本语法

**1. 创建**

```sql
CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])
BEGIN
    -- SQL语句
END ;
```

**2. 调用**

```sql
CALL 名称 ([ 参数 ]);
```

**3. 查看**

```sql
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'; -- 查询指定数据库的存储过程及状态信息
SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义
```

**4. 删除**

```sql
DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；
```

**注意：**

在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。

**演示示例：**

```sql
-- 存储过程基本语法
-- 创建
create procedure p1()
begin
    select count(*) from student;
end;

-- 调用
call p1();

-- 查看
select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast';
show create procedure p1;

-- 删除
drop procedure if exists p1;
```

**DELIMITER说明：**
- MySQL默认使用`;`作为语句结束符
- 存储过程内部也需要`;`，会产生冲突
- 使用`DELIMITER`临时改变结束符为`$$`
- 创建完成后再改回`;`

---

## 二、变量

### 2.1 系统变量

系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。

**1). 查看系统变量**

```sql
SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量
SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......'; -- 可以通过LIKE模糊匹配方式查找变量
SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值
```

**注意：**
如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。

- **A. 全局变量(GLOBAL)：** 全局变量针对于所有的会话。
- **B. 会话变量(SESSION)：** 会话变量针对于单个会话，在另外一个会话窗口就不生效了。

**演示示例：**

```sql
-- 查看系统变量
show session variables ;
show session variables like 'auto%';
show global variables like 'auto%';
select @@global.autocommit;
select @@session.autocommit;

-- 设置系统变量
set session autocommit = 1;
insert into course(id, name) VALUES (6, 'ES');
set global autocommit = 0;
select @@global.autocommit;
```

**2). 设置系统变量**

```sql
SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;
SET @@[SESSION | GLOBAL]系统变量名 = 值 ;
```

**注意：**
mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。

### 2.2 用户定义变量

用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 "@变量名" 使用就可以。其作用域为当前连接。

**1). 赋值**

**方式一：**

```sql
SET @var_name = expr [, @var_name = expr] ... ;
SET @var_name := expr [, @var_name := expr] ... ;
```

赋值时，可以使用 = ，也可以使用 := 。

**方式二：**

```sql
SELECT @var_name := expr [, @var_name := expr] ... ;
SELECT 字段名 INTO @var_name FROM 表名;
```

**2). 使用**

```sql
SELECT @var_name ;
```

**注意：** 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。

**演示示例：**

```sql
-- 赋值
set @myname = 'itcast';
set @myage := 10;
set @mygender := '男',@myhobby := 'java';
select @mycolor := 'red';
select count(*) into @mycount from tb_user;

-- 使用
select @myname,@myage,@mygender,@myhobby;
select @mycolor , @mycount;
select @abc;
```

### 2.3 局部变量

局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN ... END块。

**1). 声明**

```sql
DECLARE 变量名 变量类型 [DEFAULT ... ] ;
```

变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。

**2). 赋值**

```sql
SET 变量名 = 值 ;
SET 变量名 := 值 ;
SELECT 字段名 INTO 变量名 FROM 表名 ... ;
```

**演示示例：**

```sql
-- 声明局部变量 - declare
-- 赋值
create procedure p2()
begin
    declare stu_count int default 0;
    select count(*) into stu_count from student;
    select stu_count;
end;

call p2();
```

**三种变量对比：**

| 类型 | 作用域 | 声明方式 | 前缀 |
|------|--------|---------|------|
| 系统变量 | 全局/会话 | 系统定义 | @@ |
| 用户变量 | 当前连接 | 无需声明 | @ |
| 局部变量 | BEGIN...END | DECLARE | 无 |

---

## 三、流程控制

### 3.1 IF 条件判断

**1). 介绍**

if 用于做条件判断，具体的语法结构为：

```sql
IF 条件1 THEN
    .....
ELSEIF 条件2 THEN -- 可选
    .....
ELSE -- 可选
    .....
END IF;
```

在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。

**2). 案例**

根据定义的分数score变量，判定当前分数对应的分数等级。

- score >= 85分，等级为优秀。
- score >= 60分 且 score < 85分，等级为及格。
- score < 60分，等级为不及格。

```sql
create procedure p3()
begin
    declare score int default 58;
    declare result varchar(10);
    if score >= 85 then
        set result := '优秀';
    elseif score >= 60 then
        set result := '及格';
    else
        set result := '不及格';
    end if;
    select result;
end;

call p3();
```

### 3.2 参数

**1). 介绍**

参数的类型，主要分为以下三种：IN、OUT、INOUT。具体的含义如下：

| 类型 | 含义 | 备注 |
|------|------|------|
| IN | 该类参数作为输入，也就是需要调用时传入值 | 默认 |
| OUT | 该类参数作为输出，也就是该参数可以作为返回值 | |
| INOUT | 既可以作为输入参数，也可以作为输出参数 | |

**用法：**

```sql
CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])
BEGIN
    -- SQL语句
END ;
```

上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。

那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？答案是肯定的，我们可以通过接下来所讲解的 **参数** 来解决上述的问题。

**2). 案例一**

根据传入参数score，判定当前分数对应的分数等级，并返回。

- score >= 85分，等级为优秀。
- score >= 60分 且 score < 85分，等级为及格。
- score < 60分，等级为不及格。

```sql
create procedure p4(in score int, out result varchar(10))
begin
    if score >= 85 then
        set result := '优秀';
    elseif score >= 60 then
        set result := '及格';
    else
        set result := '不及格';
    end if;
end;

-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明
call p4(18, @result);
select @result;
```

**3). 案例二**

将传入的200分制的分数，进行换算，换算成百分制，然后返回。

```sql
create procedure p5(inout score double)
begin
    set score := score * 0.5;
end;

set @score = 198;
call p5(@score);
select @score;
```

### 3.3 CASE 语句

**1). 介绍**

case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：

**语法1：**

```sql
-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list
CASE case_value
    WHEN when_value1 THEN statement_list1
    [ WHEN when_value2 THEN statement_list2] ...
    [ ELSE statement_list ]
END CASE;
```

**语法2：**

```sql
-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list
CASE
    WHEN search_condition1 THEN statement_list1
    [WHEN search_condition2 THEN statement_list2] ...
    [ELSE statement_list]
END CASE;
```

**2). 案例**

根据传入的月份，判定月份所属的季节（要求采用case结构）。

- 1-3月份，为第一季度
- 4-6月份，为第二季度
- 7-9月份，为第三季度
- 10-12月份，为第四季度

```sql
create procedure p6(in month int)
begin
    declare result varchar(10);
    case
        when month >= 1 and month <= 3 then
            set result := '第一季度';
        when month >= 4 and month <= 6 then
            set result := '第二季度';
        when month >= 7 and month <= 9 then
            set result := '第三季度';
        when month >= 10 and month <= 12 then
            set result := '第四季度';
        else
            set result := '非法参数';
    end case ;
    select concat('您输入的月份为: ',month, ', 所属的季度为: ',result);
end;

call p6(16);
```

**注意：** 如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。

### 3.4 WHILE 循环

**1). 介绍**

while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：

```sql
-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑
WHILE 条件 DO
    SQL逻辑...
END WHILE;
```

**2). 案例**

计算从1累加到n的值，n为传入的参数值。

```sql
-- A. 定义局部变量, 记录累加之后的值;
-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环
create procedure p7(in n int)
begin
    declare total int default 0;
    while n>0 do
        set total := total + n;
        set n := n - 1;
    end while;
    select total;
end;

call p7(100);
```

### 3.5 REPEAT 循环

**1). 介绍**

repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环。具体语法为：

```sql
-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环
REPEAT
    SQL逻辑...
    UNTIL 条件
END REPEAT;
```

**2). 案例**

计算从1累加到n的值，n为传入的参数值。(使用repeat实现)

```sql
-- A. 定义局部变量, 记录累加之后的值;
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环
create procedure p8(in n int)
begin
    declare total int default 0;
    repeat
        set total := total + n;
        set n := n - 1;
        until n <= 0
    end repeat;
    select total;
end;

call p8(10);
call p8(100);
```

### 3.6 LOOP 循环

**1). 介绍**

LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。

LOOP可以配合一下两个语句使用：

- **LEAVE**：配合循环使用，退出循环。
- **ITERATE**：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。

上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。

```sql
[begin_label:] LOOP
    SQL逻辑...
END LOOP [end_label];
```

```sql
LEAVE label; -- 退出指定标记的循环体
ITERATE label; -- 直接进入下一次循环
```

**2). 案例一**

计算从1累加到n的值，n为传入的参数值。

```sql
-- A. 定义局部变量, 记录累加之后的值;
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----> leave xx
create procedure p9(in n int)
begin
    declare total int default 0;
    sum:loop
        if n<=0 then
            leave sum;
        end if;
        set total := total + n;
        set n := n - 1;
    end loop sum;
    select total;
end;

call p9(100);
```

**3). 案例二**

计算从1到n之间的偶数累加的值，n为传入的参数值。

```sql
-- A. 定义局部变量, 记录累加之后的值;
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----> leave xx
-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------> iterate xx
create procedure p10(in n int)
begin
    declare total int default 0;
    sum:loop
        if n<=0 then
            leave sum;
        end if;
        if n%2 = 1 then
            set n := n - 1;
            iterate sum;
        end if;
        set total := total + n;
        set n := n - 1;
    end loop sum;
    select total;
end;

call p10(100);
```

---

## 四、游标和异常处理

### 4.1 游标（Cursor）

**1). 介绍**

游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。

**A. 声明游标**

```sql
DECLARE 游标名称 CURSOR FOR 查询语句 ;
```

**B. 打开游标**

```sql
OPEN 游标名称 ;
```

**C. 获取游标记录**

```sql
FETCH 游标名称 INTO 变量 [, 变量 ] ;
```

**D. 关闭游标**

```sql
CLOSE 游标名称 ;
```

**2). 案例**

根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。

```sql
-- 逻辑:
-- A. 声明游标, 存储查询结果集
-- B. 准备: 创建表结构
-- C. 开启游标
-- D. 获取游标中的记录
-- E. 插入数据到新表中
-- F. 关闭游标
create procedure p11(in uage int)
begin
    declare uname varchar(100);
    declare upro varchar(100);
    declare u_cursor cursor for select name,profession from tb_user where age <= uage;
    
    drop table if exists tb_user_pro;
    create table if not exists tb_user_pro(
        id int primary key auto_increment,
        name varchar(100),
        profession varchar(100)
    );
    
    open u_cursor;
    while true do
        fetch u_cursor into uname,upro;
        insert into tb_user_pro values (null, uname, upro);
    end while;
    close u_cursor;
end;

call p11(30);
```

上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。

![image-20260112100749414](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100749414.png)

但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100758994.png" alt="image-20260112100758994" style="zoom:50%;" />

上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。接下来，我们就需要来完成这个存储过程，并且解决这个问题。

要想解决这个问题，就需要通过MySQL中提供的 **条件处理程序 Handler** 来解决。

### 4.2 条件处理程序（Handler）

**1). 介绍**

条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：

```sql
DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement ;
```

**handler_action 的取值：**
- CONTINUE: 继续执行当前程序
- EXIT: 终止执行当前程序

**condition_value 的取值：**
- SQLSTATE sqlstate_value: 状态码，如 02000
- SQLWARNING: 所有以01开头的SQLSTATE代码的简写
- NOT FOUND: 所有以02开头的SQLSTATE代码的简写
- SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写

**2). 案例**

我们继续来完成在上一小节提出的这个需求，并解决其中的问题。

根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。

**A. 通过SQLSTATE指定具体的状态码**

```sql
-- 逻辑:
-- A. 声明游标, 存储查询结果集
-- B. 准备: 创建表结构
-- C. 开启游标
-- D. 获取游标中的记录
-- E. 插入数据到新表中
-- F. 关闭游标
create procedure p11(in uage int)
begin
    declare uname varchar(100);
    declare upro varchar(100);
    declare u_cursor cursor for select name,profession from tb_user where age <= uage;
    
    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出
    declare exit handler for SQLSTATE '02000' close u_cursor;
    
    drop table if exists tb_user_pro;
    create table if not exists tb_user_pro(
        id int primary key auto_increment,
        name varchar(100),
        profession varchar(100)
    );
    
    open u_cursor;
    while true do
        fetch u_cursor into uname,upro;
        insert into tb_user_pro values (null, uname, upro);
    end while;
    close u_cursor;
end;

call p11(30);
```

**B. 通过SQLSTATE的代码简写方式 NOT FOUND**

02 开头的状态码，代码简写为 NOT FOUND

```sql
create procedure p12(in uage int)
begin
    declare uname varchar(100);
    declare upro varchar(100);
    declare u_cursor cursor for select name,profession from tb_user where age <= uage;
    
    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出
    declare exit handler for not found close u_cursor;
    
    drop table if exists tb_user_pro;
    create table if not exists tb_user_pro(
        id int primary key auto_increment,
        name varchar(100),
        profession varchar(100)
    );
    
    open u_cursor;
    while true do
        fetch u_cursor into uname,upro;
        insert into tb_user_pro values (null, uname, upro);
    end while;
    close u_cursor;
end;

call p12(30);
```

具体的错误状态码，可以参考官方文档：
- https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html
- https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html

**示例：异常处理**
```sql
DELIMITER $$

CREATE PROCEDURE p_exception_demo()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 发生异常时回滚
        ROLLBACK;
        SELECT '操作失败，已回滚' AS message;
    END;
    
    START TRANSACTION;
    
    -- 可能出错的操作
    INSERT INTO users VALUES (1, '张三');
    INSERT INTO users VALUES (1, '李四');  -- 主键冲突
    
    COMMIT;
    SELECT '操作成功' AS message;
END$$

DELIMITER ;
```

---

## 五、存储函数

### 5.1 存储函数 vs 存储过程

| 特性 | 存储函数 | 存储过程 |
|------|---------|---------|
| 返回值 | 必须有返回值 | 可以无返回值 |
| 参数 | 只能是IN类型 | IN/OUT/INOUT |
| 调用方式 | SELECT function() | CALL procedure() |
| 使用场景 | 计算并返回单个值 | 复杂业务逻辑 |

### 5.2 创建存储函数

**1). 介绍**

存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：

```sql
CREATE FUNCTION 存储函数名称 ([ 参数列表 ])
RETURNS type [characteristic ...]
BEGIN
    -- SQL语句
    RETURN ...;
END ;
```

**characteristic说明：**
- DETERMINISTIC：相同的输入参数总是产生相同的结果
- NO SQL ：不包含 SQL 语句。
- READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。

在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报如下错误。

![image-20260112101027093](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112101027093.png)

**2). 案例**

计算从1累加到n的值，n为传入的参数值。

```sql
DELIMITER $$

CREATE FUNCTION fn_sum(n INT)
RETURNS INT DETERMINISTIC
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    
    WHILE i <= n DO
        SET total = total + i;
        SET i = i + 1;
    END WHILE;
    
    RETURN total;
END$$

DELIMITER ;

-- 调用
SELECT fn_sum(100);  -- 输出：5050
```

**示例2：复杂函数**
```sql
DELIMITER $$

-- 计算学生平均分
CREATE FUNCTION fn_avg_score(stu_id INT)
RETURNS DECIMAL(5,2) READS SQL DATA
BEGIN
    DECLARE avg_score DECIMAL(5,2);
    
    SELECT AVG(score) INTO avg_score
    FROM scores
    WHERE student_id = stu_id;
    
    RETURN IFNULL(avg_score, 0);
END$$

DELIMITER ;

-- 调用
SELECT fn_avg_score(1);
SELECT name, fn_avg_score(id) AS avg_score FROM students;
```

### 5.3 删除存储函数

```sql
DROP FUNCTION IF EXISTS fn_sum;
```

---

## 六、综合案例

### 案例：银行转账存储过程

```sql
DELIMITER $$

CREATE PROCEDURE p_transfer(
    IN from_account INT,
    IN to_account INT,
    IN amount DECIMAL(10,2),
    OUT result VARCHAR(100)
)
BEGIN
    DECLARE from_balance DECIMAL(10,2);
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET result = '转账失败：发生异常';
    END;
    
    -- 开启事务
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO from_balance 
    FROM accounts 
    WHERE account_id = from_account FOR UPDATE;
    
    IF from_balance < amount THEN
        ROLLBACK;
        SET result = '转账失败：余额不足';
    ELSE
        -- 扣款
        UPDATE accounts 
        SET balance = balance - amount 
        WHERE account_id = from_account;
        
        -- 入账
        UPDATE accounts 
        SET balance = balance + amount 
        WHERE account_id = to_account;
        
        COMMIT;
        SET result = '转账成功';
    END IF;
END$$

DELIMITER ;

-- 调用
CALL p_transfer(1, 2, 100, @result);
SELECT @result;
```

---

## 七、本章总结

### 核心要点

1. **存储过程**：预编译的SQL集合，提高性能和复用性
2. **变量类型**：系统变量、用户变量、局部变量
3. **参数类型**：IN（输入）、OUT（输出）、INOUT（输入输出）
4. **流程控制**：IF、CASE、WHILE、REPEAT、LOOP
5. **游标**：处理查询结果集
6. **异常处理**：HANDLER捕获异常
7. **存储函数**：有返回值，用于计算

### 最佳实践

1. ✅ 使用有意义的命名：`p_` 开头表示过程，`fn_` 表示函数
2. ✅ 添加注释说明参数和逻辑
3. ✅ 使用异常处理保证数据一致性
4. ✅ 复杂逻辑使用事务
5. ✅ 避免过度使用存储过程（维护成本高）

---

## 练习题

```sql
-- 1. 创建存储过程：根据部门ID统计员工数和平均工资
DELIMITER $$
CREATE PROCEDURE p_dept_stats(IN dept_id INT)
BEGIN
    SELECT 
        COUNT(*) AS emp_count,
        AVG(salary) AS avg_salary
    FROM employees
    WHERE department_id = dept_id;
END$$
DELIMITER ;

-- 2. 创建存储函数：计算员工工龄
DELIMITER $$
CREATE FUNCTION fn_work_years(hire_date DATE)
RETURNS INT DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, hire_date, CURDATE());
END$$
DELIMITER ;

SELECT name, fn_work_years(hire_date) AS work_years FROM employees;
```

---

**上一章：** [视图](/tutorials/java-backend/mysql/第03章-高级篇/04-视图/)

**下一章：** [触发器](/tutorials/java-backend/mysql/第03章-高级篇/06-触发器/) →
