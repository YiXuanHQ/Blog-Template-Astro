---
title: 视图
prevChapter: "java-backend/mysql/第03章-高级篇/03-SQL性能优化"
nextChapter: "java-backend/mysql/第03章-高级篇/05-存储过程"
parentChapter: "java-backend/mysql/README"
---
# 视图

> 视图是虚拟表，简化复杂查询，提高SQL的可重用性和安全性。本章学习视图的创建和使用，掌握视图是提高SQL开发效率的重要工具。

## ⚡ 快速参考

- **视图定义**：虚拟表，数据来自基础表，只存储SQL逻辑，不存储数据
- **视图特点**：动态生成、实时反映基础表变化、可隐藏复杂查询、提高安全性
- **视图操作**：CREATE VIEW、ALTER VIEW、DROP VIEW、SHOW CREATE VIEW
- **视图优势**：简化复杂查询、提高代码复用、数据安全（隐藏敏感字段）、逻辑独立
- **视图限制**：不能使用临时表、不能使用子查询中的某些语法、更新有限制
- **视图分类**：普通视图、物化视图（MySQL不支持，但可通过表模拟）

## 📚 学习目标

1. 理解视图的概念和特点，掌握视图与表的区别
2. 掌握视图的创建、修改和删除操作
3. 理解视图的优势和使用场景
4. 掌握通过视图进行数据查询的方法
5. 理解视图的更新限制和注意事项
6. 能够使用视图简化复杂查询，提高代码可维护性
7. 掌握视图在权限控制和数据安全中的应用
8. 理解视图的性能影响，合理使用视图

## 一、视图概述

### 1.1 什么是视图？

**视图（View）** 是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。

通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。

**特点：**
- 📝 视图是虚拟表，数据来自基础表
- 🔄 动态生成数据，实时反映基础表的变化
- 💾 只存储SQL定义，不存储数据
- 🔒 可以隐藏复杂查询，提高安全性

### 1.2 视图 vs 表

| 特性 | 视图 | 表 |
|------|------|-----|
| 数据存储 | ❌ 不存储数据 | ✅ 存储实际数据 |
| 占用空间 | 极小（只存SQL） | 根据数据量 |
| 更新限制 | 有限制 | 无限制 |
| 性能 | 依赖基础表 | 直接查询 |
| 用途 | 简化查询、权限控制 | 存储数据 |

### 1.3 视图的优势

**1. 简化复杂查询**
```sql
-- 不使用视图：每次都要写复杂SQL
SELECT u.name, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;

-- 使用视图：简化查询
CREATE VIEW v_user_orders AS
SELECT u.name, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;

-- 使用时只需：
SELECT * FROM v_user_orders;
```

**2. 提高安全性**
```sql
-- 隐藏敏感字段（如密码、工资）
CREATE VIEW v_public_users AS
SELECT id, name, email FROM users;  -- 不包含password字段
```

**3. 数据独立性**
- 表结构改变时，视图可以保持接口不变
- 应用程序不需要修改

---

## 二、视图操作

### 2.1 创建视图

**语法：**
```sql
CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)]
AS
SELECT 语句
[WITH [CASCADED | LOCAL] CHECK OPTION];
```

**示例1：基本视图**
```sql
-- 创建视图
create or replace view stu_v_1 as select id,name from student where id <= 10;

-- 查询视图
select * from stu_v_1;
select * from stu_v_1 where id < 3;
```

**示例2：复杂视图**
```sql
-- 创建订单统计视图
CREATE VIEW v_user_order_stats AS
SELECT 
    u.id,
    u.name AS user_name,
    COUNT(o.id) AS order_count,
    IFNULL(SUM(o.amount), 0) AS total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 使用视图
SELECT * FROM v_user_order_stats WHERE order_count > 5;
```

**示例3：OR REPLACE（更新视图）**
```sql
-- 如果视图存在则替换
create or replace view stu_v_1 as select id,name,no from student where id <= 10;
```

### 2.2 查看视图

**查看创建视图语句：**
```sql
show create view 视图名称;
```

**查看视图数据：**
```sql
select * from 视图名称 ...... ;
```

**完整示例：**
```sql
-- 查看创建视图语句
show create view stu_v_1;

-- 查看视图数据
select * from stu_v_1;
select * from stu_v_1 where id < 3;

-- 查看所有视图（视图也会显示在表列表中）
SHOW TABLES;

-- 查看视图结构
DESC stu_v_1;
```

### 2.3 修改视图

**方式一：CREATE OR REPLACE**
```sql
create [or replace] view 视图名称[(列名列表)] as select语句 [ with [ cascaded | local ] check option ]
```

**方式二：ALTER VIEW**
```sql
alter view 视图名称[(列名列表)] as select语句 [ with [ cascaded | local ] check option ]
```

**示例：**
```sql
-- 方式1：CREATE OR REPLACE
create or replace view stu_v_1 as select id,name,no from student where id <= 10;

-- 方式2：ALTER VIEW
alter view stu_v_1 as select id,name from student where id <= 10;
```

### 2.4 删除视图

**语法：**
```sql
drop view [if exists] 视图名称 [,视图名称] ...
```

**示例：**
```sql
-- 删除单个视图
drop view if exists stu_v_1;

-- 删除多个视图
DROP VIEW IF EXISTS v_student, v_user_orders;
```

### 2.5 演示示例

上述我们演示了，视图应该如何创建、查询、修改、删除，那么我们能不能通过视图来插入、更新数据呢？接下来，做一个测试。

```sql
create or replace view stu_v_1 as select id,name from student where id <= 10 ;

select * from stu_v_1;

insert into stu_v_1 values(6,'Tom');
insert into stu_v_1 values(17,'Tom22');
```

执行上述的SQL，我们会发现，id为6和17的数据都是可以成功插入的。但是我们执行查询，查询出来的数据，却没有id为17的记录。

![image-20260112100126875](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100126875.png)

因为我们在创建视图的时候，指定的条件为 id<=10, id为17的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。

如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？答案是可以的，这就需要借助于视图的检查选项了。

---

## 三、检查选项

### 3.1 WITH CHECK OPTION

当使用 `WITH CHECK OPTION` 子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：CASCADED 和 LOCAL，默认值为 CASCADED。

### 3.2 CASCADED（默认）

**CASCADED（级联）** 是默认选项，会递归检查所有依赖视图的条件。

比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。

![image-20260112100154412](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100154412.png)

```sql
-- 创建基础视图
CREATE VIEW v1 AS
SELECT * FROM students WHERE age >= 18;

-- 创建级联检查视图
CREATE VIEW v2 AS
SELECT * FROM v1 WHERE age <= 25
WITH CASCADED CHECK OPTION;

-- ✅ 可以插入（满足 age>=18 AND age<=25）
INSERT INTO v2 VALUES (1, '张三', 20, '一班');

-- ❌ 插入失败（age=30 不满足 v2 的条件 age<=25）
INSERT INTO v2 VALUES (2, '李四', 30, '二班');

-- ❌ 插入失败（age=16 不满足 v1 的条件 age>=18）
INSERT INTO v2 VALUES (3, '王五', 16, '三班');
```

**CASCADED 检查逻辑：**
- 检查 v2 的条件：age <= 25
- 递归检查 v1 的条件：age >= 18
- 两个条件都要满足

### 3.3 LOCAL

**LOCAL（本地）** 只检查当前视图的条件，不递归检查依赖视图。

比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local，但是v1视图创建时未指定检查选项。则在执行检查时，只会检查v2，不会检查v2的关联视图v1。

![image-20260112100207752](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100207752.png)

```sql
-- 创建基础视图（无检查选项）
CREATE VIEW v1 AS
SELECT * FROM students WHERE age >= 18;

-- 创建本地检查视图
CREATE VIEW v2 AS
SELECT * FROM v1 WHERE age <= 25
WITH LOCAL CHECK OPTION;

-- ✅ 可以插入（只检查 v2 的条件 age<=25）
INSERT INTO v2 VALUES (1, '张三', 20, '一班');

-- ❌ 插入失败（不满足 v2 的条件 age<=25）
INSERT INTO v2 VALUES (2, '李四', 30, '二班');

-- ⚠️ 可以插入（LOCAL不检查v1的条件，但实际上违反了age>=18）
-- 注意：虽然可以尝试插入，但如果基础表有约束可能还是会失败
INSERT INTO v2 VALUES (3, '王五', 16, '三班');
```

### 3.4 对比总结

| 选项 | 检查范围 | 使用场景 |
|------|---------|---------|
| **CASCADED** | 递归检查所有视图条件 | 严格数据验证（推荐） |
| **LOCAL** | 只检查当前视图条件 | 灵活的数据插入 |
| **不使用** | 不检查条件 | 只读视图 |

---

## 四、视图的更新

### 4.1 可更新视图

视图可更新的条件：视图中的行与基础表中的行存在 **一对一** 的关系。

**可更新的视图示例：**
```sql
-- 简单视图（可更新）
CREATE VIEW v_students AS
SELECT id, name, age FROM students;

-- 可以进行增删改操作
INSERT INTO v_students VALUES (100, '新学生', 20);
UPDATE v_students SET age = 21 WHERE id = 100;
DELETE FROM v_students WHERE id = 100;
```

### 4.2 不可更新视图

如果视图包含以下任意一项，则视图 **不可更新**：

**A. 聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等）**

```sql
create view stu_v_count as select count(*) from student;

-- ❌ 不能更新（上述的视图中，就只有一个单行单列的数据，如果我们对这个视图进行更新或插入的，将会报错）
insert into stu_v_count values(10);
```

![image-20260112100320691](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112100320691.png)

**示例演示：**

```sql
CREATE VIEW v_avg_age AS
SELECT class, AVG(age) AS avg_age FROM students GROUP BY class;

-- ❌ 不能更新
UPDATE v_avg_age SET avg_age = 20 WHERE class = '一班';
```

**B. DISTINCT**

```sql
CREATE VIEW v_distinct_class AS
SELECT DISTINCT class FROM students;

-- ❌ 不能更新
```

**C. GROUP BY**
```sql
CREATE VIEW v_class_count AS
SELECT class, COUNT(*) AS cnt FROM students GROUP BY class;

-- ❌ 不能更新
```

**D. HAVING**
```sql
CREATE VIEW v_class_having AS
SELECT class, COUNT(*) AS cnt 
FROM students 
GROUP BY class 
HAVING COUNT(*) > 5;

-- ❌ 不能更新
```

**E. UNION 或者 UNION ALL**
```sql
CREATE VIEW v_union AS
SELECT id, name FROM students
UNION
SELECT id, name FROM teachers;

-- ❌ 不能更新
```

**F. 子查询**
```sql
CREATE VIEW v_subquery AS
SELECT * FROM students 
WHERE age > (SELECT AVG(age) FROM students);

-- ❌ 不能更新
```

### 4.3 更新限制总结

| 视图类型 | 是否可更新 | 示例 |
|---------|----------|------|
| 简单SELECT | ✅ 可以 | SELECT id, name FROM t |
| 包含聚合函数 | ❌ 不可以 | SELECT AVG(age) ... |
| 包含DISTINCT | ❌ 不可以 | SELECT DISTINCT ... |
| 包含GROUP BY | ❌ 不可以 | ... GROUP BY class |
| 包含JOIN | ⚠️ 部分可以 | 取决于具体情况 |

---

## 五、视图作用

### 5.1 简单

视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。

### 5.2 安全

数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。

### 5.3 数据独立

视图可帮助用户屏蔽真实表结构变化带来的影响。

---

## 六、实际工作中何时用视图？

### 6.1 场景1：简化复杂查询（最常用）

```sql
-- 场景：经常需要查询用户的订单统计信息
CREATE VIEW v_user_stats AS
SELECT 
    u.id,
    u.username,
    u.email,
    COUNT(o.id) AS order_count,
    SUM(o.amount) AS total_spent,
    MAX(o.create_time) AS last_order_time
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username, u.email;

-- 使用时非常简单
SELECT * FROM v_user_stats WHERE order_count > 10;
```

### 6.2 场景2：权限控制和数据安全（重要）

**真实案例**：一个公司的员工管理系统，不同部门看到的数据不同。

```sql
-- HR部门：只能看基本信息（不包含工资）
CREATE VIEW v_hr_employees AS
SELECT id, name, dept, hire_date, phone, email FROM employees;
GRANT SELECT ON v_hr_employees TO 'hr_user'@'%';

-- 财务部门：可以看工资信息
CREATE VIEW v_finance_employees AS
SELECT id, name, dept, salary, bonus FROM employees;
GRANT SELECT ON v_finance_employees TO 'finance_user'@'%';

-- 普通员工：只能看自己的信息
CREATE VIEW v_my_profile AS
SELECT id, name, email, phone, dept FROM employees 
WHERE username = USER();
GRANT SELECT ON v_my_profile TO 'employee'@'%';

-- 经理：可以看本部门员工信息
CREATE VIEW v_dept_employees AS
SELECT e.id, e.name, e.position, e.hire_date
FROM employees e
WHERE e.dept_id = (
    SELECT dept_id FROM employees WHERE username = USER()
);
```

**为什么用视图**：
- ✅ 不同用户看不同数据，无需修改应用代码
- ✅ 隐藏敏感字段（如密码、工资）
- ✅ 细粒度的权限控制
- ✅ 数据安全性更高

**实际工作中的应用**：
- 🏢 OA系统：不同级别员工看到不同审批流程
- 💰 财务系统：只有财务人员能看金额
- 📊 数据分析：给分析师提供脱敏后的数据视图
- 🏥 医疗系统：医生只能看自己的患者

### 6.3 数据格式转换

```sql
-- 场景：格式化显示数据
CREATE VIEW v_formatted_orders AS
SELECT 
    order_id,
    user_name,
    DATE_FORMAT(order_time, '%Y-%m-%d %H:%i:%s') AS order_time,
    CONCAT('¥', FORMAT(amount, 2)) AS amount_formatted,
    CASE status
        WHEN 1 THEN '待支付'
        WHEN 2 THEN '已支付'
        WHEN 3 THEN '已发货'
        WHEN 4 THEN '已完成'
        ELSE '未知'
    END AS status_text
FROM orders;
```

### 6.4 兼容性

```sql
-- 场景：表结构改变，但保持对外接口不变
-- 原表：users(id, name, address)
-- 新表：users(id, name), addresses(user_id, address)

-- 创建视图保持兼容
CREATE VIEW v_users_compatible AS
SELECT u.id, u.name, a.address
FROM users u
LEFT JOIN addresses a ON u.id = a.user_id;

-- 应用程序不需要修改
SELECT * FROM v_users_compatible;
```

---

## 七、案例

### 7.1 案例1：屏蔽敏感字段

为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。

```sql
-- 创建视图，只显示基本字段（不包含手机号和邮箱）
CREATE VIEW v_user_basic AS
SELECT id, username, name, gender, status, create_time 
FROM tb_user;

-- 开发人员使用视图进行操作
SELECT * FROM v_user_basic;
```

### 7.2 案例2：简化多表联查

查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。

```sql
-- 创建视图：学生选课信息
CREATE VIEW v_student_course AS
SELECT 
    s.id AS student_id,
    s.name AS student_name,
    c.id AS course_id,
    c.course_name,
    sc.score,
    sc.create_time AS select_time
FROM student s
JOIN student_course sc ON s.id = sc.student_id
JOIN course c ON sc.course_id = c.id;

-- 使用视图查询（简化操作）
SELECT * FROM v_student_course WHERE student_id = 1;
SELECT student_name, course_name, score FROM v_student_course;
```

---

## 八、最佳实践

### 8.1 命名规范

```sql
-- 建议视图名以 v_ 开头
CREATE VIEW v_user_orders AS ...
CREATE VIEW v_product_stats AS ...
```

### 8.2 性能注意事项

**1. 避免嵌套过深**
```sql
-- ❌ 不推荐：视图嵌套过深
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE VIEW v2 AS SELECT * FROM v1;
CREATE VIEW v3 AS SELECT * FROM v2;  -- 影响性能
```

**2. 复杂视图考虑物化**
```sql
-- 对于复杂统计，考虑创建物理表定期更新
CREATE TABLE t_user_stats AS
SELECT ... FROM users ... ;  -- 定期更新
```

### 8.3 安全性

```sql
-- 创建视图时指定字段，不用 SELECT *
CREATE VIEW v_users AS
SELECT id, name, email FROM users;  -- ✅ 明确字段

-- 而不是
CREATE VIEW v_users AS
SELECT * FROM users;  -- ❌ 可能暴露敏感字段
```

---

## 九、本章总结

### 核心要点

1. **视图是虚拟表**：只存储SQL定义，不存储数据
2. **简化查询**：隐藏复杂SQL逻辑
3. **权限控制**：不同用户看不同视图
4. **WITH CHECK OPTION**：CASCADED递归检查，LOCAL只检查当前
5. **更新限制**：包含聚合、DISTINCT、GROUP BY等的视图不可更新

### 使用建议

| 场景 | 建议 |
|------|------|
| 简化复杂查询 | ✅ 推荐使用视图 |
| 权限控制 | ✅ 推荐使用视图 |
| 频繁更新数据 | ❌ 不推荐视图 |
| 大量计算统计 | ⚠️ 考虑物化表 |

---

## 练习题

```sql
-- 1. 创建学生成绩视图
CREATE VIEW v_student_scores AS
SELECT 
    s.id,
    s.name,
    c.course_name,
    sc.score
FROM students s
JOIN scores sc ON s.id = sc.student_id
JOIN courses c ON sc.course_id = c.id;

-- 2. 创建平均分统计视图
CREATE VIEW v_avg_scores AS
SELECT 
    s.id,
    s.name,
    AVG(sc.score) AS avg_score,
    COUNT(*) AS course_count
FROM students s
JOIN scores sc ON s.id = sc.student_id
GROUP BY s.id, s.name;

-- 3. 带检查选项的视图
CREATE VIEW v_high_score AS
SELECT * FROM scores WHERE score >= 60
WITH CASCADED CHECK OPTION;

-- 测试插入
INSERT INTO v_high_score VALUES (1, 1, 1, 85);  -- ✅ 可以
INSERT INTO v_high_score VALUES (2, 2, 2, 50);  -- ❌ 失败
```

---

**上一章：** [SQL性能优化](/tutorials/java-backend/mysql/第03章-高级篇/03-SQL性能优化/)

**下一章：** [存储过程](/tutorials/java-backend/mysql/第03章-高级篇/05-存储过程/) →
