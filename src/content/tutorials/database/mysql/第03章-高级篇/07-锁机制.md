---
title: 锁机制
prevChapter: "java-backend/mysql/第03章-高级篇/06-触发器"
nextChapter: "java-backend/mysql/第03章-高级篇/08-InnoDB引擎"
parentChapter: "java-backend/mysql/README"
---
# 锁机制

> 锁是数据库并发控制的核心机制。本章学习MySQL的锁类型和使用场景，掌握锁机制是保证数据一致性和并发性能的关键技术。

## ⚡ 快速参考

- **锁定义**：协调多个进程或线程并发访问资源的机制，保证数据一致性
- **锁粒度**：全局锁（锁定所有表）、表级锁（锁定整张表）、行级锁（锁定行数据）
- **表级锁**：表锁（TABLE LOCK）、元数据锁（MDL）、意向锁（IS/IX）
- **行级锁**：共享锁（S锁/读锁）、排他锁（X锁/写锁）、记录锁、间隙锁、临键锁
- **锁类型**：乐观锁（版本号）、悲观锁（数据库锁）、死锁检测与处理
- **锁使用**：SELECT ... FOR UPDATE（排他锁）、SELECT ... LOCK IN SHARE MODE（共享锁）
- **性能影响**：锁冲突影响并发性能，需要合理设计锁策略

## 📚 学习目标

1. 理解锁的概念和作用，掌握锁在并发控制中的重要性
2. 理解不同锁粒度（全局锁、表级锁、行级锁）的特点和使用场景
3. 掌握表级锁的类型和使用方法
4. 深入理解行级锁的类型（共享锁、排他锁、记录锁、间隙锁、临键锁）
5. 理解意向锁的作用和原理
6. 掌握死锁的产生原因、检测和解决方法
7. 理解锁对性能的影响，能够优化锁的使用
8. 掌握在实际业务中合理使用锁的策略

## 一、锁概述

### 1.1 什么是锁？

**锁** 是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

MySQL中的锁，按照锁的粒度分，分为以下三类：
- **全局锁**：锁定数据库中的所有表。
- **表级锁**：每次操作锁住整张表。
- **行级锁**：每次操作锁住对应的行数据。

**为什么需要锁？**
```sql
-- 场景：两个用户同时购买最后一件商品
-- 用户A：查询库存 → 库存=1 → 下单扣减库存
-- 用户B：查询库存 → 库存=1 → 下单扣减库存
-- 结果：两个用户都成功，但实际只有1件商品！

-- 使用锁解决：
SELECT stock FROM products WHERE id = 1 FOR UPDATE;  -- 加锁
-- 只有一个用户能获取锁，另一个必须等待
```

### 1.2 锁的分类

**按锁粒度分类：**

```
锁的粒度
├── 全局锁：锁定整个数据库
├── 表级锁：锁定整张表
└── 行级锁：锁定具体的行
```

**特点对比：**

| 锁类型 | 粒度 | 并发性 | 开销 | 死锁风险 |
|--------|------|--------|------|----------|
| **全局锁** | 最大 | 最差 | 最小 | 无 |
| **表级锁** | 中等 | 一般 | 较小 | 较低 |
| **行级锁** | 最小 | 最好 | 最大 | 较高 |

### 1.3 锁模式

**按操作类型分类：**

| 锁模式 | 说明 | 其他事务能读？ | 其他事务能写？ |
|--------|------|---------------|---------------|
| **共享锁（S锁）** | 读锁 | ✅ 能 | ❌ 不能 |
| **排他锁（X锁）** | 写锁 | ❌ 不能 | ❌ 不能 |

**兼容性矩阵：**

|  | 共享锁（S） | 排他锁（X） |
|--|------------|------------|
| **共享锁（S）** | ✅ 兼容 | ❌ 冲突 |
| **排他锁（X）** | ❌ 冲突 | ❌ 冲突 |

### 1.4 实际工作中何时用锁？

**场景1：秒杀抢购（最典型）**
```sql
-- 业务场景：100个用户同时抢购1件商品
START TRANSACTION;
-- 使用排他锁锁定库存记录
SELECT stock FROM products WHERE id = 1001 FOR UPDATE;
-- 检查库存
IF stock > 0 THEN
    UPDATE products SET stock = stock - 1 WHERE id = 1001;
    INSERT INTO orders (user_id, product_id) VALUES (1001, 1001);
END IF;
COMMIT;
```
**为什么用锁**：
- ✅ 防止超卖：确保库存不会变成负数
- ✅ `FOR UPDATE`加排他锁，同一时刻只有一个事务能操作
- ✅ 其他事务必须等待，避免并发问题

**场景2：账户转账（金融系统）**
```sql
START TRANSACTION;
-- 锁定两个账户，防止并发转账导致余额错误
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- 锁定账户A
SELECT balance FROM accounts WHERE id = 2 FOR UPDATE;  -- 锁定账户B
-- 扣款
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
-- 入账
UPDATE accounts SET balance = balance + 1000 WHERE id = 2;
COMMIT;
```
**为什么用锁**：防止同时有多个转账操作，导致余额计算错误。

**场景3：订单编号生成（唯一性保证）**
```sql
START TRANSACTION;
-- 锁定编号表，生成唯一订单号
SELECT next_no FROM order_no_seq WHERE id = 1 FOR UPDATE;
-- 更新编号
UPDATE order_no_seq SET next_no = next_no + 1 WHERE id = 1;
-- 使用编号创建订单
INSERT INTO orders (order_no, ...) VALUES (next_no, ...);
COMMIT;
```
**为什么用锁**：保证订单号唯一，不会重复。

**场景4：库存扣减（电商系统）**
```sql
START TRANSACTION;
-- 悲观锁：先锁定再操作
SELECT stock FROM products WHERE id = 100 FOR UPDATE;
UPDATE products SET stock = stock - 1 WHERE id = 100 AND stock > 0;
COMMIT;

-- 或使用乐观锁（无锁）
UPDATE products SET stock = stock - 1, version = version + 1 
WHERE id = 100 AND stock > 0 AND version = 10;
-- 如果version不匹配，说明被别人修改过，更新失败
```

**场景5：座位选座（电影票、高铁票）**
```sql
START TRANSACTION;
-- 锁定座位，防止多人选择同一座位
SELECT status FROM seats WHERE id = 10 FOR UPDATE;
IF status = 'available' THEN
    UPDATE seats SET status = 'locked', user_id = 1001 WHERE id = 10;
END IF;
COMMIT;
```

**什么时候用共享锁（读锁）？**
```sql
-- 场景：读取数据时防止被修改
START TRANSACTION;
SELECT * FROM products WHERE id = 1 LOCK IN SHARE MODE;  -- 或 FOR SHARE
-- 其他事务可以读，但不能写
-- ... 业务逻辑 ...
COMMIT;
```
**实际应用**：报表生成、数据一致性校验

**什么时候用排他锁（写锁）？**
```sql
-- 场景：修改数据前锁定，防止其他人读写
SELECT * FROM products WHERE id = 1 FOR UPDATE;
UPDATE products SET price = 999 WHERE id = 1;
```
**实际应用**：秒杀、转账、扣库存等

**实际工作经验：**
- 🏪 **电商**：秒杀、库存扣减 → 必须用锁
- 💰 **金融**：转账、支付 → 必须用锁
- 🎫 **票务**：选座、抢票 → 必须用锁
- 📊 **普通查询**：不需要用锁
- 📝 **日志表**：写多读少，不需要用锁

**锁的选择建议：**
- ✅ **悲观锁**（FOR UPDATE）：并发高、冲突多的场景
- ✅ **乐观锁**（版本号）：并发低、冲突少的场景
- ⚠️ **注意死锁**：多个事务相互等待

---

## 二、全局锁

### 2.1 什么是全局锁？

**全局锁** 就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

**为什么全库逻辑备份，就需要加全局锁呢？**

**A. 不加全局锁，可能存在的问题**

假设在数据库中存在这样三张表：tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112102654322.png" alt="image-20260112102654322" style="zoom:50%;" />

在进行数据备份时：
1. 先备份了tb_stock库存表
2. 然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）
3. 然后再执行备份tb_order表的逻辑
4. 业务中执行插入订单日志操作
5. 最后，又备份了tb_orderlog表

此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致（有最新操作的订单信息，但是库存数没减）。

**B. 加了全局锁后的情况**

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112102706052.png" alt="image-20260112102706052" style="zoom: 67%;" />

对数据库进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。

### 2.2 全局锁语法

**1). 加全局锁**
```sql
FLUSH TABLES WITH READ LOCK;
```

**2). 数据备份**
数据备份的相关指令，在后面MySQL管理章节，还会详细讲解。
```bash
mysqldump -uroot –p1234 itcast > itcast.sql
```

**3). 释放锁**
```sql
UNLOCK TABLES;
```

**完整示例：**
```sql
-- 加全局锁
FLUSH TABLES WITH READ LOCK;

-- 此时：
-- ✅ 可以执行：SELECT（DQL）
-- ❌ 被阻塞：INSERT、UPDATE、DELETE（DML）
-- ❌ 被阻塞：CREATE、ALTER、DROP（DDL）
-- ❌ 被阻塞：事务提交语句

-- 执行备份（在另一个终端）
-- mysqldump -u root -p database_name > backup.sql

-- 释放全局锁
UNLOCK TABLES;
```

### 2.3 全局锁的特点

数据库中加全局锁，是一个比较重的操作，存在以下问题：

**问题1：主库备份**
- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
- 影响用户体验

**问题2：从库备份**
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。

### 2.4 InnoDB的一致性备份

在InnoDB引擎中，我们可以在备份时加上参数 `--single-transaction` 参数来完成不加锁的一致性数据备份：

```bash
mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```

**原理：**利用MVCC实现一致性快照读

**对比：**

| 方式 | 是否加锁 | 影响业务 | 适用引擎 |
|------|---------|---------|---------|
| FLUSH TABLES | ✅ 加锁 | ❌ 影响大 | 所有引擎 |
| --single-transaction | ❌ 不加锁 | ✅ 几乎无影响 | InnoDB |

---

## 三、表级锁

### 3.1 表级锁概述

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。

对于表级锁，主要分为以下三类：
- **表锁**
- **元数据锁（meta data lock，MDL）**
- **意向锁**

### 3.2 表锁（Table Lock）

**表锁类型：**
- **表共享读锁（read lock）**：阻塞写操作
- **表独占写锁（write lock）**：阻塞读写操作

**语法：**
```sql
-- 加锁
LOCK TABLES 表名 READ;   -- 读锁
LOCK TABLES 表名 WRITE;  -- 写锁

-- 释放锁
UNLOCK TABLES;
-- 或客户端断开连接自动释放
```

**示例：读锁**

![image-20260112105109697](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105109697.png)

左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。

测试:

![image-20260112105128743](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105128743.png)

```sql
-- 客户端A
LOCK TABLES products READ;
SELECT * FROM products;     -- ✅ 可以
UPDATE products SET price = 100;  -- ❌ 不能写
SELECT * FROM orders;       -- ❌ 不能访问其他表

-- 客户端B
SELECT * FROM products;     -- ✅ 可以读
UPDATE products SET price = 100;  -- ❌ 等待（被阻塞）

-- 客户端A释放锁
UNLOCK TABLES;
-- 客户端B的UPDATE立即执行
```

**示例：写锁**

![image-20260112105147485](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105147485.png)

左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。

测试:

![image-20260112105200400](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105200400.png)

```sql
-- 客户端A
LOCK TABLES products WRITE;
SELECT * FROM products;     -- ✅ 可以
UPDATE products SET price = 100;  -- ✅ 可以

-- 客户端B
SELECT * FROM products;     -- ❌ 等待（被阻塞）
UPDATE products SET price = 100;  -- ❌ 等待（被阻塞）

-- 客户端A释放锁
UNLOCK TABLES;
```

**表锁特点：**
- ✅ 开销小，加锁快
- ❌ 锁粒度大，并发度低
- ✅ 不会出现死锁

**结论：** 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

### 3.3 元数据锁（MDL）

**元数据锁（meta data lock，MDL）** 由系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。

这里的元数据，大家可以简单理解为就是一张表的表结构。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。

在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。

**常见的SQL操作时，所添加的元数据锁：**

| 对应SQL | 锁类型 | 说明 |
|---------|--------|------|
| `lock tables xxx read / write` | SHARED_READ_ONLY / SHARED_NO_READ_WRITE | |
| `select`、`select ... lock in share mode` | SHARED_READ | 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 |
| `insert`、`update`、`delete`、`select ... for update` | SHARED_WRITE | 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 |
| `alter table ...` | EXCLUSIVE | 与其他的MDL都互斥 |

**演示：MDL锁的作用**

当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的。

![image-20260112105227956](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105227956.png)

当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。

![image-20260112105235964](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105235964.png)

```sql
-- 会话1：开启事务，查询数据（加MDL读锁）
BEGIN;
SELECT * FROM users WHERE id = 1;  -- 加MDL读锁

-- 会话2：修改表结构（需要MDL写锁）
ALTER TABLE users ADD COLUMN phone VARCHAR(20);  -- 等待（被阻塞）

-- 会话1：提交事务（释放MDL读锁）
COMMIT;

-- 会话2：ALTER立即执行
```

我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：

**查看MDL锁：**

```sql
SELECT 
    object_type,
    object_schema,
    object_name,
    lock_type,
    lock_duration
FROM performance_schema.metadata_locks;
```

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105313711.png" alt="image-20260112105313711"  />

**MDL锁问题：**

```sql
-- ⚠️ 场景：长事务持有MDL读锁
BEGIN;
SELECT * FROM users;  -- MDL读锁
-- ... 长时间不提交 ...

-- 其他会话的DDL会被阻塞，导致：
-- 1. 后续所有访问该表的操作都被阻塞
-- 2. 数据库连接堆积
-- 3. 系统雪崩

-- 解决：及时提交事务，避免长事务
```

### 3.4 意向锁（Intention Lock）

**1). 介绍**

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。

**没有意向锁的情况：**

假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：

首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105511355.png" alt="image-20260112105511355" style="zoom:50%;" />

当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105540324.png" alt="image-20260112105540324" style="zoom:50%;" />

**有了意向锁之后：**

- 客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105559009.png" alt="image-20260112105559009" style="zoom: 67%;" />

- 其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105614076.png" alt="image-20260112105614076" style="zoom: 50%;" />

**2). 分类**

- **意向共享锁(IS)**：由语句`select ... lock in share mode`添加。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
- **意向排他锁(IX)**：由`insert`、`update`、`delete`、`select...for update`添加。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。

一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。

**兼容性矩阵：**

|  | IS | IX | S | X |
|--|----|----|---|---|
| **IS** | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ |
| **S** | ✅ | ❌ | ✅ | ❌ |
| **X** | ❌ | ❌ | ❌ | ❌ |

**可以通过以下SQL，查看意向锁及行锁的加锁情况：**
```sql
SELECT 
    object_schema,
    object_name,
    index_name,
    lock_type,
    lock_mode,
    lock_data
FROM performance_schema.data_locks;
```

**演示：**

**A. 意向共享锁与表读锁是兼容的**

![image-20260112105631893](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105631893.png)

```sql
-- 会话1：开启事务，加意向共享锁
BEGIN;
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;  -- 加IS锁

-- 会话2：加表读锁
LOCK TABLES users READ;  -- ✅ 成功（IS与表读锁兼容）
UNLOCK TABLES;
```

**B. 意向排他锁与表读锁、写锁都是互斥的**

![image-20260112105639555](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105639555.png)

```sql
-- 会话1：开启事务，加意向排他锁
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;  -- 加IX锁

-- 会话2：加表读锁
LOCK TABLES users READ;  -- ❌ 等待（IX与表读锁互斥）

-- 会话3：加表写锁
LOCK TABLES users WRITE;  -- ❌ 等待（IX与表写锁互斥）

-- 会话1：提交事务（释放IX锁）
COMMIT;

-- 会话2和会话3的锁请求可以继续执行
```

---

## 四、行级锁

### 4.1 行级锁概述

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。

InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

- **行锁（Record Lock）**：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
- ![image-20260112105715309](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105715309.png)
- **间隙锁（Gap Lock）**：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
- ![image-20260112105720622](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105720622.png)
- **临键锁（Next-Key Lock）**：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。
- ![image-20260112105725587](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105725587.png)

### 4.2 行锁（Record Lock）

**1). 介绍**

InnoDB实现了以下两种类型的行锁：

- **共享锁（S）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
- **排他锁（X）**：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

两种行锁的兼容情况如下:

|  | 共享锁（S） | 排他锁（X） |
|--|------------|------------|
| **共享锁（S）** | ✅ 兼容 | ❌ 冲突 |
| **排他锁（X）** | ❌ 冲突 | ❌ 冲突 |

**常见的SQL语句，在执行时，所加的行锁如下：**

| SQL | 行锁类型 | 说明 |
|-----|---------|------|
| `INSERT ...` | 排他锁 | 自动加锁 |
| `UPDATE ...` | 排他锁 | 自动加锁 |
| `DELETE ...` | 排他锁 | 自动加锁 |
| `SELECT（正常）` | 不加任何锁 | |
| `SELECT ... LOCK IN SHARE MODE` | 共享锁 | 需要手动在SELECT之后加LOCK IN SHARE MODE |
| `SELECT ... FOR UPDATE` | 排他锁 | 需要手动在SELECT之后加FOR UPDATE |

**2). 演示**

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。

针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。

InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。

**可以通过以下SQL，查看意向锁及行锁的加锁情况：**
```sql
SELECT 
    object_schema,
    object_name,
    index_name,
    lock_type,
    lock_mode,
    lock_data
FROM performance_schema.data_locks;
```

**示例演示**

**数据准备：**
```sql
CREATE TABLE `stu` (
    `id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `name` varchar(255) DEFAULT NULL,
    `age` int NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4;

INSERT INTO `stu` VALUES (1, 'tom', 1);
INSERT INTO `stu` VALUES (3, 'cat', 3);
INSERT INTO `stu` VALUES (8, 'rose', 8);
INSERT INTO `stu` VALUES (11, 'jetty', 11);
INSERT INTO `stu` VALUES (19, 'lily', 19);
INSERT INTO `stu` VALUES (25, 'luci', 25);
```

演示行锁的时候，我们就通过上面这张表来演示一下。

**A. 普通的select语句，执行时，不会加锁。**

![image-20260112105757928](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105757928.png)

```sql
-- 会话1
BEGIN;
SELECT * FROM stu WHERE id = 1;  -- 普通查询，不加锁
COMMIT;
```

**B. select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。**

![image-20260112105806241](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105806241.png)

```sql
-- 会话1
BEGIN;
SELECT * FROM stu WHERE id = 1 LOCK IN SHARE MODE;  -- 加共享锁

-- 会话2：也可以加共享锁（兼容）
BEGIN;
SELECT * FROM stu WHERE id = 1 LOCK IN SHARE MODE;  -- ✅ 成功
COMMIT;

-- 会话1
COMMIT;
```

**共享锁与排他锁之间互斥。**

![image-20260112105843287](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105843287.png)

客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，因为共享锁与排他锁之间互斥。

```sql
-- 会话1
BEGIN;
SELECT * FROM stu WHERE id = 1 LOCK IN SHARE MODE;  -- 加共享锁

-- 会话2：加排他锁（冲突）
BEGIN;
UPDATE stu SET name = 'new' WHERE id = 1;  -- ❌ 等待（被阻塞）

-- 会话1
COMMIT;  -- 释放共享锁

-- 会话2：UPDATE立即执行
COMMIT;
```

**C. 排它锁与排他锁之间互斥**

当客户端一，执行update语句，会为id为1的记录加排他锁；客户端二，如果也执行update语句更新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互斥的。直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。

```sql
-- 会话1
BEGIN;
UPDATE stu SET name = 'new1' WHERE id = 1;  -- 加排他锁

-- 会话2：也想更新同一行（冲突）
BEGIN;
UPDATE stu SET name = 'new2' WHERE id = 1;  -- ❌ 等待（被阻塞）

-- 会话1
COMMIT;  -- 释放排他锁

-- 会话2：UPDATE立即执行
COMMIT;
```

**D. 无索引行锁升级为表锁**

![image-20260112105943309](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105943309.png)

stu表中数据如下:

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112105950416.png" alt="image-20260112105950416" style="zoom:67%;" />

我们在两个客户端中执行如下操作:

<img src="https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112110005198.png" alt="image-20260112110005198" style="zoom:50%;" />

在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录。然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？

原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。

```sql
-- 会话1：根据无索引字段更新
BEGIN;
UPDATE stu SET age = 20 WHERE name = 'lily';  -- name无索引，锁升级为表锁

-- 会话2：更新其他行也被阻塞（表锁）
BEGIN;
UPDATE stu SET age = 10 WHERE id = 3;  -- ❌ 等待（被表锁阻塞）

-- 会话1
COMMIT;  -- 释放表锁

-- 会话2：UPDATE立即执行
COMMIT;
```

接下来，我们再针对name字段建立索引，索引建立之后，再次做一个测试：

![image-20260112110049721](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112110049721.png)

```sql
-- 创建索引
CREATE INDEX idx_name ON stu(name);

-- 会话1：根据有索引字段更新
BEGIN;
UPDATE stu SET age = 20 WHERE name = 'lily';  -- name有索引，只锁对应行

-- 会话2：更新其他行可以成功
BEGIN;
UPDATE stu SET age = 10 WHERE id = 3;  -- ✅ 成功（不在同一行）
COMMIT;

-- 会话1
COMMIT;
```

此时我们可以看到，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3的数据时，更新成功，并未进入阻塞状态。这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。

**示例：共享锁**

```sql
-- 会话1：加共享锁
BEGIN;
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;

-- 会话2：也可以加共享锁（兼容）
BEGIN;
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;  -- ✅ 成功

-- 会话3：加排他锁（冲突）
BEGIN;
UPDATE users SET name = '李四' WHERE id = 1;  -- ❌ 等待
```

**示例：排他锁**
```sql
-- 会话1：加排他锁
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 会话2：任何锁都会冲突
SELECT * FROM users WHERE id = 1;  -- ✅ 普通查询不加锁，可以执行
SELECT * FROM users WHERE id = 1 FOR SHARE;  -- ❌ 等待
UPDATE users SET name = '李四' WHERE id = 1;  -- ❌ 等待
```

### 4.3 间隙锁&临键锁

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。

**间隙锁（Gap Lock）**：锁定索引记录之间的间隙，防止幻读。

**临键锁（Next-Key Lock）**：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。

**注意：**间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。

**示例演示**

**A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁。**

![image-20260112110130586](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112110130586.png)

```sql
-- 假设id有：1, 3, 8, 11, 19, 25
-- 间隙：(-∞, 1), (1, 3), (3, 8), (8, 11), (11, 19), (19, 25), (25, +∞)

-- 会话1：查询id=7（不存在），会加间隙锁
BEGIN;
SELECT * FROM stu WHERE id = 7 FOR UPDATE;  -- 锁间隙 (3, 8)

-- 会话2：插入间隙内的值
INSERT INTO stu VALUES (7, 'test', 7);  -- ❌ 等待（被间隙锁阻塞）
INSERT INTO stu VALUES (2, 'test', 2);  -- ✅ 成功（不在间隙内）
INSERT INTO stu VALUES (10, 'test', 10); -- ✅ 成功（不在间隙内）

-- 会话1
COMMIT;  -- 释放间隙锁

-- 会话2：INSERT立即执行
COMMIT;
```

**B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。**

介绍分析一下：

我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。

![image-20260112110139053](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112110139053.png)

![image-20260112110151468](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112110151468.png)

```sql
-- 创建索引
CREATE INDEX idx_age ON stu(age);

-- 假设age有：1, 3, 8, 11, 19, 25

-- 会话1：查询age=18（不存在），会加间隙锁
BEGIN;
SELECT * FROM stu WHERE age = 18 FOR UPDATE;  -- 锁间隙 (11, 19)

-- 会话2：插入间隙内的值
INSERT INTO stu VALUES (NULL, 'test', 15);  -- ❌ 等待（被间隙锁阻塞）
INSERT INTO stu VALUES (NULL, 'test', 10);  -- ✅ 成功（不在间隙内）
INSERT INTO stu VALUES (NULL, 'test', 20);  -- ✅ 成功（不在间隙内）

-- 会话1
COMMIT;
```

**C. 索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止。**

![image-20260112110216184](https://raw.gitcode.com/YiXuanHQ/YiXuan-Blog-Image/raw/main/tutorials/java-backend/mysql/image-20260112110216184.png)

查询的条件为id>=19，并添加共享锁。此时我们可以根据数据库表中现有的数据，将数据分为三个部分：
- [19]
- (19,25]
- (25,+∞]

所以数据库数据在加锁时，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。

```sql
-- 假设id有：1, 3, 8, 11, 19, 25

-- 会话1：范围查询
BEGIN;
SELECT * FROM stu WHERE id >= 19 FOR UPDATE;
-- 加锁：
-- 1. id=19的行锁
-- 2. (19,25]的临键锁（包含25及25之前的间隙）
-- 3. (25,+∞)的临键锁

-- 会话2：尝试插入或更新
INSERT INTO stu VALUES (20, 'test', 20);  -- ❌ 等待（在(19,25]范围内）
INSERT INTO stu VALUES (30, 'test', 30);  -- ❌ 等待（在(25,+∞)范围内）
UPDATE stu SET name = 'new' WHERE id = 25;  -- ❌ 等待（25被临键锁锁定）
INSERT INTO stu VALUES (15, 'test', 15);  -- ✅ 成功（不在锁定范围内）

-- 会话1
COMMIT;
```

### 4.4 行锁的退化

**1. 唯一索引等值查询（记录存在）**
```sql
-- 临键锁退化为行锁
SELECT * FROM stu WHERE id = 19 FOR UPDATE;
-- 只锁 id=19 这一行
```

**2. 唯一索引等值查询（记录不存在）**
```sql
-- 临键锁退化为间隙锁
SELECT * FROM stu WHERE id = 7 FOR UPDATE;  -- id=7不存在
-- 只锁间隙 (3, 8)
```

**3. 非唯一索引等值查询**
```sql
-- 使用临键锁 + 间隙锁
SELECT * FROM stu WHERE age = 19 FOR UPDATE;
-- 锁定匹配记录 + 向右的间隙
```

### 4.5 查看锁信息

```sql
-- 查看事务
SELECT * FROM information_schema.INNODB_TRX;

-- 查看锁
SELECT * FROM performance_schema.data_locks;

-- 查看锁等待
SELECT * FROM performance_schema.data_lock_waits;

-- 查看是否有锁等待
SHOW ENGINE INNODB STATUS;
```

---

## 五、锁问题与优化

### 5.1 死锁

**死锁：**两个或多个事务相互等待对方释放锁，形成循环等待。

**示例：**
```sql
-- 会话1
BEGIN;
UPDATE users SET name = 'A' WHERE id = 1;  -- 锁住id=1
-- 等待获取id=2的锁
UPDATE users SET name = 'A' WHERE id = 2;  -- ❌ 等待

-- 会话2
BEGIN;
UPDATE users SET name = 'B' WHERE id = 2;  -- 锁住id=2
-- 等待获取id=1的锁
UPDATE users SET name = 'B' WHERE id = 1;  -- ❌ 等待

-- 结果：死锁！MySQL自动检测并回滚其中一个事务
```

**查看死锁日志：**
```sql
SHOW ENGINE INNODB STATUS;
-- 查看 LATEST DETECTED DEADLOCK 部分
```

**避免死锁：**
1. ✅ 按相同顺序访问资源
2. ✅ 缩短事务时间
3. ✅ 降低事务隔离级别
4. ✅ 使用合理的索引
5. ✅ 避免大事务

### 5.2 锁等待超时

```sql
-- 查看锁等待超时时间
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';  -- 默认50秒

-- 设置超时时间
SET innodb_lock_wait_timeout = 10;  -- 10秒
```

### 5.3 优化建议

**1. 使用合适的索引**
```sql
-- ❌ 没有索引：锁全表
UPDATE users SET name = '张三' WHERE age = 25;

-- ✅ 有索引：只锁匹配的行
CREATE INDEX idx_age ON users(age);
UPDATE users SET name = '张三' WHERE age = 25;
```

**2. 缩小锁范围**
```sql
-- ❌ 锁范围大
BEGIN;
SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;
-- ... 很多操作 ...
COMMIT;

-- ✅ 锁范围小
BEGIN;
-- ... 其他操作 ...
SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;
-- 立即更新
UPDATE orders SET status = 2 WHERE user_id = 1;
COMMIT;
```

**3. 降低隔离级别**
```sql
-- RR级别有间隙锁，可能导致更多锁等待
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- RC级别没有间隙锁，并发性能更好（但可能幻读）
```

**4. 分批处理大事务**
```sql
-- ❌ 一次更新100万行
UPDATE orders SET status = 2 WHERE create_time < '2023-01-01';

-- ✅ 分批处理
DELIMITER $$
CREATE PROCEDURE batch_update()
BEGIN
    DECLARE done INT DEFAULT 0;
    WHILE done = 0 DO
        UPDATE orders SET status = 2 
        WHERE create_time < '2023-01-01' 
        LIMIT 1000;
        
        IF ROW_COUNT() = 0 THEN
            SET done = 1;
        END IF;
        
        -- 休息一下，释放锁
        DO SLEEP(0.1);
    END WHILE;
END$$
DELIMITER ;
```

**5. 使用乐观锁**
```sql
-- 乐观锁：使用版本号
UPDATE products 
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 10;

-- 如果version不匹配，说明被其他事务修改过
```

---

## 六、本章总结

### 核心要点

1. **锁的分类**：全局锁、表级锁、行级锁
2. **锁的模式**：共享锁（S）、排他锁（X）
3. **表级锁**：表锁、MDL锁、意向锁
4. **行级锁**：行锁、间隙锁、临键锁
5. **锁问题**：死锁、锁等待超时

### 锁粒度对比

| 锁类型 | 并发性 | 开销 | 适用场景 |
|--------|--------|------|---------|
| 全局锁 | 最差 | 最小 | 全库备份 |
| 表级锁 | 一般 | 较小 | MyISAM、DDL |
| 行级锁 | 最好 | 最大 | InnoDB OLTP |

### 优化策略

| 问题 | 解决方案 |
|------|---------|
| 死锁 | 按顺序访问、缩短事务、降低隔离级别 |
| 锁等待 | 优化索引、缩小锁范围、分批处理 |
| 性能差 | 使用行锁、避免长事务、合理用锁 |

---

## 练习题

```sql
-- 1. 体验行锁
-- 会话1
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 会话2
SELECT * FROM users WHERE id = 1 FOR UPDATE;  -- 等待

-- 2. 体验间隙锁
-- 会话1
BEGIN;
SELECT * FROM users WHERE id > 5 AND id < 10 FOR UPDATE;

-- 会话2
INSERT INTO users VALUES (7, '测试');  -- 等待

-- 3. 查看锁信息
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;
```

---

**上一章：** [触发器](/tutorials/java-backend/mysql/第03章-高级篇/06-触发器/)

**下一章：** [InnoDB引擎](/tutorials/java-backend/mysql/第03章-高级篇/08-InnoDB引擎/) →

**恭喜完成MySQL高级篇学习！** 🎉
